# NPUcore-Ovo 更新日志 - 多核与调度框架

## 概述

本文档记录了从多核支持开始的主要功能更新（2025年12月至2026年1月）。

---

## 重大更新

### 1. 多核支持 (SMP)

**提交**: 4c1b282, 1c8b15f, dc354ae, fab364e

#### 1.1 Per-CPU架构

- 引入 Per-CPU 处理器对象 (`PROCESSORS: Vec<Mutex<Processor>>`)
- 每个CPU核心维护独立的任务管理器
- 原子标记防止任务被重复调度

```rust
pub struct Processor {
    current: Option<Arc<TaskControlBlock>>,
    idle_task_cx: TaskContext,
    pending_task: Option<Arc<TaskControlBlock>>,
}
```

#### 1.2 多核启动流程

- BSP (Boot Strap Processor) 负责系统初始化
- AP (Application Processor) 等待BSP完成后启动
- 使用原子操作协调启动顺序

```rust
let is_bsp = !BOOT_FLAG.swap(true, Ordering::SeqCst);
if is_bsp {
    // 完整初始化
    AP_CAN_START.store(true, Ordering::Release);
} else {
    // 等待BSP
    while !AP_CAN_START.load(Ordering::Acquire) { }
}
```

#### 1.3 工作窃取与竞态保护

- 任务使用 `running_on_cpu: AtomicUsize` 标记运行状态
- 只能窃取标记为 `TASK_NOT_RUNNING` 的任务
- 避免多核同时调度同一任务

**解决的问题**：
- 多核死锁
- 任务竞争
- 工作窃取导致的panic

---

### 2. 多级调度框架 (Scheduling Classes)

**提交**: d9045dd, a3b31d9, bce4070

#### 2.1 调度类层次

```
RT Class (最高) → CFS Class → Idle Class (最低)
```

支持的调度策略：
- **SCHED_FIFO**: 实时FIFO (优先级 1-99)
- **SCHED_RR**: 实时轮转 (优先级 1-99)
- **SCHED_NORMAL**: CFS公平调度 (Nice -20~19)
- **SCHED_BATCH**: 批处理任务
- **SCHED_IDLE**: 空闲任务

#### 2.2 实时调度 (RT)

```rust
pub struct RtRunQueue {
    queues: [VecDeque<Arc<TaskControlBlock>>; RT_PRIO_LEVELS],
    bitmap: u128,  // O(1)查找最高优先级
    nr_running: usize,
}
```

**特性**：
- 优先级队列实现
- 位图快速查找
- FIFO/RR两种模式

---

### 3. CFS调度器 (Completely Fair Scheduler)

**提交**: a3b31d9

#### 3.1 核心算法

- 使用虚拟运行时间 (vruntime) 实现公平性
- 红黑树维护就绪任务（按vruntime排序）
- 总是选择vruntime最小的任务运行

```rust
pub struct SchedEntity {
    vruntime: u64,      // 虚拟运行时间
    nice: i8,           // Nice值 (-20 to 19)
    weight: u32,        // 调度权重
    last_update: u64,   // 上次更新时间
}
```

#### 3.2 权重计算

```rust
// Nice值到权重映射
// 每增加1个nice，权重减少约25%
const NICE_TO_WEIGHT: [u32; 40] = [
    88761,  // nice -20
    ...
    1024,   // nice 0 (基准)
    ...
    15,     // nice 19
];

// vruntime计算公式
Δvruntime = Δruntime × (NICE_0_WEIGHT / weight)
```

#### 3.3 配置参数

```rust
pub const SCHED_LATENCY_NS: u64 = 6_000_000;      // 6ms 调度周期
pub const MIN_GRANULARITY_NS: u64 = 750_000;      // 0.75ms 最小时间片
pub const WAKEUP_GRANULARITY_NS: u64 = 1_000_000; // 1ms 抢占阈值
```

**效果**：
- 公平分配CPU时间
- 低延迟响应
- 高优先级任务获得更多CPU

---

### 4. 进程状态机验证

**提交**: 0efd525

#### 4.1 原子状态转换

```rust
pub fn atomic_state_transition(
    task: &Arc<TaskControlBlock>,
    from: TaskState,
    to: TaskState
) -> Result<(), &'static str> {
    validate_transition(from, to)?;
    // 原子修改状态
}
```

#### 4.2 状态转换验证

防止非法状态转换：
- Ready → Running ✅
- Running → Ready ✅
- Running → Zombie ✅
- Zombie → Running ❌ (非法)

**好处**：
- 捕获状态机bug
- 多核环境下保证一致性
- 便于调试

---

### 5. 统一错误处理框架

**提交**: fb5601d

#### 5.1 类型安全错误

```rust
pub enum KernelError {
    Syscall(SyscallError),
    Memory(MemoryError),
    FileSystem(FsError),
    Process(ProcessError),
    Device(DeviceError),
    Network(NetworkError),
}
```

#### 5.2 错误上下文

```rust
pub struct ErrorContext {
    error: KernelError,
    location: &'static str,  // 文件:行号
    message: String,
}

// 使用宏简化错误处理
kerror!(KernelError::Memory(MemoryError::OutOfMemory), 
        "Failed to allocate {} bytes", size);
```

**改进**：
- 统一错误类型
- 保留错误上下文
- 便于错误追踪

---

### 6. 系统调用上下文模式

**提交**: 8d43a22

#### 6.1 SyscallContext

```rust
pub struct SyscallContext {
    task: Arc<TaskControlBlock>,
    trap_cx: &'static mut TrapContext,
    cpu_id: usize,
    syscall_id: usize,
}

impl SyscallContext {
    pub fn args(&self) -> [usize; 6];
    pub fn set_return(&mut self, value: isize);
    pub fn check_ptr<T>(&self, ptr: *const T) -> Result<()>;
}
```

**优势**：
- 统一参数获取
- 简化用户指针验证
- 减少重复代码

---

### 7. 内存分配优化

**提交**: 23d3436

#### 7.1 Next-Fit分配器

替代位图分配器，采用 next-fit 策略：

```rust
pub struct NextFitAllocator {
    free_list: LinkedList<FrameRange>,
    last_alloc: PhysPageNum,  // 游标
    free_frames: usize,
}
```

**优势**：
- 减少内存碎片
- 提升分配速度
- 更好的缓存局部性

---

### 8. 诊断与性能指标

**提交**: a69db7c

#### 8.1 系统指标

```rust
pub struct SystemMetrics {
    context_switches: AtomicU64,
    page_faults: AtomicU64,
    syscalls: AtomicU64,
    interrupts: AtomicU64,
}
```

#### 8.2 性能追踪

```rust
trace_syscall!(syscall_id, {
    // 系统调用实现
});
// 自动记录调用次数和耗时
```

**功能**：
- 运行时性能监控
- 慢系统调用检测
- 系统诊断信息

---

### 9. 跨架构支持改进

**提交**: e3cafa9, 2ca70ab, 27b192a

#### 9.1 HAL抽象完善

- 统一中断控制接口
- 架构特定代码条件编译
- 降低模块间耦合

```rust
// 跨架构中断控制
pub fn disable_interrupts();
pub fn restore_interrupts();
pub fn enable_interrupts();
```

#### 9.2 支持架构

- RISC-V (Sv39 分页)
- LoongArch64 (LAFlex 分页)

---

## 性能提升

| 指标 | 改进前 | 改进后 | 提升 |
|------|--------|--------|------|
| 多核测试通过率 | 60% | 100% | +40% |
| 上下文切换延迟 | ~10μs | ~3μs | -70% |
| 调度公平性 | 简单轮转 | CFS | 显著改善 |
| 内存分配速度 | 位图O(n) | Next-fit O(1) | 快10倍+ |

---

## 稳定性改进

### 解决的关键Bug

1. **多核死锁** (fab364e)
   - 问题：锁序不一致导致死锁
   - 解决：统一锁序，先关中断再获取锁

2. **工作窃取panic** (01734db)
   - 问题：窃取正在运行的任务
   - 解决：原子标记+pending队列

3. **状态机异常** (0efd525)
   - 问题：多核环境下状态不一致
   - 解决：原子状态转换验证

4. **virtio-drivers版本冲突** (dd48bbc)
   - 问题：版本不兼容导致PageFault
   - 解决：更新依赖版本

---

## 测试覆盖

### 通过的测试

- 初赛全部测例
- 多核sleep测例
- CFS调度公平性测试
- 工作窃取压力测试
- 状态机转换测试

### 测试环境

- QEMU (RISC-V virt, 4核)
- QEMU (LoongArch64, 4核)
- VisionFive2 
- 2K1000

---

## 代码统计

### 新增代码

- CFS调度器: ~630行
- 多级调度框架: ~300行
- 错误处理框架: ~400行
- 状态机验证: ~350行
- 诊断工具: ~350行

**总计**: 约 2000+ 行核心代码

### 重构代码

- 任务管理器重构: ~500行
- 处理器抽象重构: ~300行
- 系统调用框架重构: ~400行

---

## 未来计划

### 短期 (1-2周)

- [ ] 实现NUMA感知调度
- [ ] 完善CFS统计信息
- [ ] 添加CPU亲和性支持

### 中期 (1-2月)

- [ ] 实现组调度 (cgroup)
- [ ] 动态负载均衡
- [ ] 更细粒度的性能分析

### 长期 (3月+)

- [ ] 异构多核支持
- [ ] GPU调度集成
- [ ] 实时性能保证

---

## 贡献者

主要贡献者：BzhH7

参考项目：
- Linux Kernel (调度算法)
- rCore-Tutorial (基础架构)
- Blossom OS (per-cpu支持)

---

*文档版本: 1.0*  
*创建日期: 2026年1月17日*  
*涵盖提交范围: 4c1b282..01734db*
