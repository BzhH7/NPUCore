# NPUcore-Ovo 模块设计文档

## 1. 内存管理模块 (mm)

### 1.1 模块概述

内存管理模块负责管理系统的物理内存和虚拟内存，提供地址空间抽象、页表管理、物理页帧分配等核心功能。

### 1.2 模块结构

```
os/src/mm/
├── mod.rs              # 模块入口，导出公共接口
├── address.rs          # 地址类型定义
├── page_table.rs       # 页表操作
├── frame_allocator.rs  # 物理页帧分配器
├── heap_allocator.rs   # 内核堆分配器
├── memory_set.rs       # 地址空间管理
├── map_area.rs         # 内存映射区域
└── zram.rs             # ZRAM 压缩内存
```

### 1.3 核心数据结构

#### 1.3.1 地址类型 (address.rs)

```rust
/// 物理地址
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysAddr(pub usize);

/// 虚拟地址
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtAddr(pub usize);

/// 物理页号
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysPageNum(pub usize);

/// 虚拟页号
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtPageNum(pub usize);
```

#### 1.3.2 页帧分配器 (frame_allocator.rs)

```rust
/// 物理页帧追踪器 (RAII)
pub struct FrameTracker {
    pub ppn: PhysPageNum,
}

impl Drop for FrameTracker {
    fn drop(&mut self) {
        frame_dealloc(self.ppn);
    }
}

// 公共接口
pub fn frame_alloc() -> Option<FrameTracker>;
pub fn frames_alloc(num: usize) -> Option<Vec<FrameTracker>>;
pub fn frame_dealloc(ppn: PhysPageNum);
pub fn unallocated_frames() -> usize;
```

#### 1.3.3 地址空间 (memory_set.rs)

```rust
/// 内存集合，表示一个地址空间
pub struct MemorySet<T: PageTable> {
    page_table: T,
    areas: Vec<MapArea>,
}

impl<T: PageTable> MemorySet<T> {
    /// 创建内核空间
    pub fn new_kernel() -> Self;
    
    /// 创建用户空间
    pub fn new_bare() -> Self;
    
    /// 插入匿名映射区域
    pub fn insert_framed_area(&mut self, start: VirtAddr, end: VirtAddr, perm: MapPermission);
    
    /// mmap 系统调用实现
    pub fn mmap(&mut self, start: VirtAddr, len: usize, prot: usize, flags: usize) -> Result<usize>;
    
    /// 复制地址空间 (fork)
    pub fn from_copy_on_write(another: &mut MemorySet<T>) -> Self;
}
```

#### 1.3.4 内存映射区域 (map_area.rs)

```rust
/// 映射类型
pub enum MapType {
    Identical,  // 恒等映射 (PA == VA)
    Framed,     // 分帧映射
    Linear,     // 线性映射
}

/// 映射权限
bitflags! {
    pub struct MapPermission: u8 {
        const R = 1 << 1;  // 可读
        const W = 1 << 2;  // 可写
        const X = 1 << 3;  // 可执行
        const U = 1 << 4;  // 用户态可访问
    }
}

/// 内存映射区域
pub struct MapArea {
    pub inner: MapAreaInner,
}

pub struct MapAreaInner {
    pub vpn_range: VPNRange,
    pub map_type: MapType,
    pub permission: MapPermission,
    pub frames: Vec<Frame>,
}
```

### 1.4 初始化流程

```rust
pub fn init() {
    // 1. 初始化内核堆
    heap_allocator::init_heap();
    
    // 2. 初始化物理页帧分配器
    frame_allocator::init_frame_allocator();
    
    // 3. 激活内核页表
    KERNEL_SPACE.lock().activate();
}
```

### 1.5 关键功能

| 功能 | 函数 | 描述 |
|------|------|------|
| 页帧分配 | `frame_alloc()` | 分配单个物理页帧 |
| 批量分配 | `frames_alloc(n)` | 分配连续 n 个页帧 |
| 地址翻译 | `translate()` | 虚拟地址到物理地址转换 |
| 用户缓冲区 | `translated_byte_buffer()` | 安全访问用户空间 |
| 写时复制 | `copy_on_write()` | 处理 CoW 页面错误 |

---

## 2. 进程管理模块 (task)

### 2.1 模块概述

进程管理模块负责任务的创建、调度、同步和销毁，实现了进程和线程的统一抽象。

### 2.2 模块结构

```
os/src/task/
├── mod.rs          # 模块入口
├── task.rs         # 任务控制块定义
├── manager.rs      # 任务管理器/调度器
├── processor.rs    # 处理器抽象
├── context.rs      # 任务上下文
├── pid.rs          # PID 分配器
├── signal.rs       # 信号处理
├── threads.rs      # 线程同步 (Futex)
└── elf.rs          # ELF 加载器
```

### 2.3 核心数据结构

#### 2.3.1 任务控制块 (task.rs)

```rust
pub struct TaskControlBlock {
    // === 不可变字段 ===
    pub pid: PidHandle,           // 进程 ID
    pub tid: usize,               // 线程 ID  
    pub tgid: usize,              // 线程组 ID
    pub kstack: KernelStack,      // 内核栈
    pub ustack_base: usize,       // 用户栈基址
    pub exit_signal: Signals,     // 退出信号
    
    // === 可变字段 (Mutex) ===
    inner: Mutex<TaskControlBlockInner>,
    
    // === 可共享字段 ===
    pub exe: Arc<Mutex<FileDescriptor>>,
    pub tid_allocator: Arc<Mutex<RecycleAllocator>>,
    pub files: Arc<Mutex<FdTable>>,
    pub socket_table: Arc<Mutex<SocketTable>>,
    pub fs: Arc<Mutex<FsStatus>>,
    pub vm: Arc<Mutex<MemorySet>>,
    pub sighand: Arc<Mutex<Vec<Option<Box<SigAction>>>>>,
    pub futex: Arc<Mutex<Futex>>,
}

pub struct TaskControlBlockInner {
    pub sigmask: Signals,         // 信号掩码
    pub sigpending: Signals,      // 待处理信号
    pub trap_cx_ppn: PhysPageNum, // 陷阱上下文
    pub task_cx: TaskContext,     // 任务上下文
    pub task_status: TaskStatus,  // 任务状态
    pub parent: Option<Weak<TaskControlBlock>>,
    pub children: Vec<Arc<TaskControlBlock>>,
    pub exit_code: u32,           // 退出码
    pub heap_bottom: usize,       // 堆底
    pub rusage: Rusage,           // 资源使用
}
```

#### 2.3.2 任务状态

```rust
#[derive(Copy, Clone, PartialEq)]
pub enum TaskStatus {
    Ready,          // 就绪态
    Running,        // 运行态
    Interruptible,  // 可中断睡眠
    Zombie,         // 僵尸态
}
```

#### 2.3.3 任务上下文 (context.rs)

```rust
#[repr(C)]
pub struct TaskContext {
    ra: usize,      // 返回地址
    sp: usize,      // 栈指针
    s: [usize; 12], // 被调用者保存寄存器
}
```

#### 2.3.4 任务管理器 (manager.rs)

```rust
pub struct TaskManager {
    /// 就绪队列（支持多级调度）
    pub ready_queue: SchedRunQueue,
    /// 可中断睡眠队列
    pub interruptible_queue: VecDeque<Arc<TaskControlBlock>>,
    #[cfg(feature = "oom_handler")]
    pub active_tracker: ActiveTracker,
}

/// 多级调度运行队列
pub struct SchedRunQueue {
    /// RT 实时任务队列（最高优先级）
    pub rt_rq: RtRunQueue,
    /// CFS 普通任务队列
    pub cfs_rq: CfsRunQueue,
    /// Idle 空闲任务队列（最低优先级）
    pub idle_rq: VecDeque<Arc<TaskControlBlock>>,
}

// 全局任务管理器 (每 CPU 一个)
lazy_static! {
    pub static ref TASK_MANAGERS: [Mutex<TaskManager>; MAX_CPU_NUM] = ...;
}
```

### 2.4 多核支持与Per-CPU架构

#### 2.4.1 Per-CPU处理器

```rust
pub struct Processor {
    /// 当前正在运行的任务
    current: Option<Arc<TaskControlBlock>>,
    /// 空闲任务的上下文
    idle_task_cx: TaskContext,
    /// 待加入就绪队列的任务（解决多核竞争）
    /// 该任务的上下文已保存，等待被重新调度
    pending_task: Option<Arc<TaskControlBlock>>,
}

lazy_static! {
    /// 全局处理器数组 (每CPU一个)
    pub static ref PROCESSORS: Vec<Mutex<Processor>> = {
        let mut v = Vec::new();
        for _ in 0..MAX_CPU_NUM {
            v.push(Mutex::new(Processor::new()));
        }
        v
    };
}
```

#### 2.4.2 任务运行标记

为避免多核竞争，任务使用原子标记保护：

```rust
pub struct TaskControlBlock {
    /// 运行在哪个CPU核心上（原子操作）
    /// TASK_NOT_RUNNING (usize::MAX) 表示未运行
    /// 0..MAX_CPU_NUM 表示运行在对应CPU上
    pub running_on_cpu: AtomicUsize,
    // ... 其他字段
}

const TASK_NOT_RUNNING: usize = usize::MAX;
```

#### 2.4.3 多核调度流程

```rust
pub fn run_tasks() {
    loop {
        let cpu_id = current_cpu_id();
        
        // 1. 关中断防止重入
        disable_interrupts();
        
        let mut processor = PROCESSORS[cpu_id].lock();
        
        // 2. 处理pending任务（上一轮被切换出的任务）
        if let Some(pending) = processor.take_pending() {
            // 清除运行标记
            pending.running_on_cpu.store(TASK_NOT_RUNNING, Ordering::SeqCst);
            
            // 更新CFS vruntime
            let now = get_time_ns() as u64;
            let mut inner = pending.acquire_inner_lock();
            inner.sched_entity.update_runtime(now);
            
            // 重新加入就绪队列
            add_task_to_manager(pending, &mut manager);
        }
        
        // 3. 从就绪队列获取下一个任务
        if let Some(next_task) = fetch_task_from_manager(&mut manager) {
            // 设置运行标记
            next_task.running_on_cpu.store(cpu_id, Ordering::SeqCst);
            
            let mut next_inner = next_task.acquire_inner_lock();
            let next_cx_ptr = &next_inner.task_cx as *const TaskContext;
            next_inner.task_status = TaskStatus::Running;
            
            // 更新运行时间
            next_inner.sched_entity.last_update = get_time_ns() as u64;
            drop(next_inner);
            
            processor.current = Some(next_task);
            let idle_cx_ptr = processor.get_idle_task_cx_ptr();
            drop(processor);
            
            // 4. 上下文切换
            restore_interrupts();
            unsafe {
                __switch(idle_cx_ptr, next_cx_ptr);
            }
        } else {
            // 没有任务，进入空闲
            drop(processor);
            restore_interrupts();
            core::hint::spin_loop();
        }
    }
}
```

#### 2.4.4 工作窃取

当本地队列为空时，尝试从其他CPU队列窃取任务：

```rust
pub fn fetch_task() -> Option<Arc<TaskControlBlock>> {
    let cpu_id = current_cpu_id();
    
    // 1. 优先从本地队列获取
    if let Some(task) = fetch_local_task(cpu_id) {
        return Some(task);
    }
    
    // 2. 本地队列空，尝试工作窃取
    for other_cpu in 0..MAX_CPU_NUM {
        if other_cpu == cpu_id {
            continue;
        }
        
        if let Some(task) = try_steal_task(other_cpu) {
            // 检查任务是否可窃取（不在运行中）
            let expected = TASK_NOT_RUNNING;
            if task.running_on_cpu.load(Ordering::SeqCst) == expected {
                return Some(task);
            }
        }
    }
    
    None
}
```

### 2.5 多级调度框架 (sched_class.rs)

#### 2.5.1 调度框架概述

NPUcore-Ovo 实现了类似 Linux 的多级调度类 (Scheduling Class) 框架：

```
┌─────────────────────────────────────────┐
│          调度器框架 (Scheduler)          │
│  ┌───────────────────────────────────┐  │
│  │       RT Class (最高优先级)        │  │
│  │   Priority 99 (最高) → 1          │  │
│  │   - SCHED_FIFO: 运行到阻塞        │  │
│  │   - SCHED_RR: 时间片轮转          │  │
│  └───────────────────────────────────┘  │
│                    ↓                    │
│  ┌───────────────────────────────────┐  │
│  │      CFS Class (普通优先级)        │  │
│  │   Nice -20 → +19 (vruntime)       │  │
│  │   基于权重的公平调度               │  │
│  └───────────────────────────────────┘  │
│                    ↓                    │
│  ┌───────────────────────────────────┐  │
│  │      Idle Class (最低优先级)       │  │
│  │   仅在无其他任务时运行             │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

#### 2.5.2 实时调度类 (RT Class)

```rust
/// RT 调度策略
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum SchedPolicy {
    SchedFifo,      // SCHED_FIFO: 先进先出
    SchedRr,        // SCHED_RR: 时间片轮转
    SchedNormal,    // SCHED_NORMAL: CFS调度
    SchedBatch,     // SCHED_BATCH: 批处理
    SchedIdle,      // SCHED_IDLE: 空闲任务
}

/// RT 运行队列
pub struct RtRunQueue {
    /// 优先级队列 (1-99，索引0不使用)
    queues: [VecDeque<Arc<TaskControlBlock>>; RT_PRIO_LEVELS],
    /// 非空队列位图（O(1)查找最高优先级）
    bitmap: u128,
    /// 运行中的RT任务数量
    nr_running: usize,
}

impl RtRunQueue {
    /// 入队：添加RT任务到对应优先级队列
    pub fn enqueue(&mut self, task: Arc<TaskControlBlock>, entity: &SchedEntity) {
        let prio = entity.rt_priority.min(MAX_RT_PRIO) as usize;
        
        // SCHED_FIFO: 加入队尾
        // SCHED_RR: 加入队尾（时钟中断会重新入队）
        self.queues[prio].push_back(task);
        self.bitmap |= 1u128 << prio;
        self.nr_running += 1;
    }
    
    /// 出队：获取最高优先级任务
    pub fn dequeue(&mut self) -> Option<Arc<TaskControlBlock>> {
        // 找到最高优先级（最高位）
        if self.bitmap == 0 {
            return None;
        }
        
        let highest_prio = 127 - self.bitmap.leading_zeros() as usize;
        
        let task = self.queues[highest_prio].pop_front()?;
        if self.queues[highest_prio].is_empty() {
            self.bitmap &= !(1u128 << highest_prio);
        }
        self.nr_running -= 1;
        
        Some(task)
    }
}
```

**RT调度特点**：
- **SCHED_FIFO**: 运行直到阻塞、主动让出或被更高优先级抢占
- **SCHED_RR**: 类似FIFO，但有时间片限制 (默认100ms)
- 优先级范围：1-99（99最高）
- RT任务总是优先于CFS和Idle任务

### 2.6 CFS调度器 (cfs_scheduler.rs)

#### 2.6.1 CFS核心概念

CFS (Completely Fair Scheduler) 实现公平的CPU时间分配：

```rust
/// 调度实体（每个任务）
pub struct SchedEntity {
    /// 虚拟运行时间（纳秒）
    pub vruntime: u64,
    /// Nice值 (-20 到 19)
    pub nice: i8,
    /// 调度权重 (从nice计算)
    pub weight: u32,
    /// 调度策略
    pub policy: SchedPolicy,
    /// RT优先级 (1-99)
    pub rt_priority: u8,
    /// 上次更新时间
    pub last_update: u64,
}

impl SchedEntity {
    /// 更新运行时间并计算vruntime
    pub fn update_runtime(&mut self, now: u64) {
        let delta = now.saturating_sub(self.last_update);
        
        // vruntime增长 = 实际运行时间 × (NICE_0_WEIGHT / weight)
        let vruntime_delta = (delta as u128 * NICE_0_WEIGHT as u128 / self.weight as u128) as u64;
        
        self.vruntime = self.vruntime.saturating_add(vruntime_delta);
        self.last_update = now;
    }
}
```

#### 2.6.2 Nice值与权重映射

Nice值决定任务的CPU份额：

```rust
/// Nice值到权重映射表
const NICE_TO_WEIGHT: [u32; 40] = [
    88761, 71755, 56483, 46273, 36291,  // nice -20 to -16
    29154, 23254, 18705, 14949, 11916,  // nice -15 to -11
    9548,  7620,  6100,  4904,  3906,   // nice -10 to -6
    3121,  2501,  1991,  1586,  1277,   // nice -5 to -1
    1024,  820,   655,   526,   423,    // nice 0 to 4 (1024为基准)
    335,   272,   215,   172,   137,    // nice 5 to 9
    110,   87,    70,    56,    45,     // nice 10 to 14
    36,    29,    23,    18,    15,     // nice 15 to 19
];

/// 权重比例：每增加1个nice值，权重减少约25%
/// 权重计算公式：weight ≈ 1024 / 1.25^nice
pub fn nice_to_weight(nice: i8) -> u32 {
    let clamped = nice.clamp(-20, 19);
    NICE_TO_WEIGHT[(clamped + 20) as usize]
}
```

**示例**：
- Nice 0 (默认): weight = 1024，获得基准CPU份额
- Nice -10: weight = 9548，约为nice 0的9.3倍CPU时间
- Nice 10: weight = 110，约为nice 0的1/9 CPU时间

#### 2.6.3 CFS运行队列

```rust
/// CFS 运行队列（红黑树实现）
pub struct CfsRunQueue {
    /// 按vruntime排序的任务树
    tasks: BTreeMap<u64, Vec<Arc<TaskControlBlock>>>,
    /// 当前最小vruntime（全局基准）
    min_vruntime: u64,
    /// 运行中的任务数量
    nr_running: usize,
    /// 所有任务权重之和
    total_weight: u64,
}

impl CfsRunQueue {
    /// 入队：插入任务到红黑树
    pub fn enqueue(&mut self, task: Arc<TaskControlBlock>) {
        let inner = task.acquire_inner_lock();
        let vruntime = inner.sched_entity.vruntime;
        drop(inner);
        
        self.tasks.entry(vruntime)
            .or_insert_with(Vec::new)
            .push(task.clone());
        
        self.nr_running += 1;
        self.update_total_weight();
    }
    
    /// 出队：选择vruntime最小的任务
    pub fn dequeue(&mut self) -> Option<Arc<TaskControlBlock>> {
        let (&min_vrt, tasks) = self.tasks.iter_mut().next()?;
        
        let task = tasks.pop()?;
        if tasks.is_empty() {
            self.tasks.remove(&min_vrt);
        }
        
        self.nr_running -= 1;
        self.update_min_vruntime();
        self.update_total_weight();
        
        Some(task)
    }
    
    /// 计算任务应分配的时间片
    pub fn calculate_timeslice(&self, task_weight: u32) -> u64 {
        if self.total_weight == 0 {
            return SCHED_LATENCY_NS;
        }
        
        // timeslice = SCHED_LATENCY_NS × (task_weight / total_weight)
        let slice = (SCHED_LATENCY_NS as u128 * task_weight as u128 
                    / self.total_weight as u128) as u64;
        
        // 保证最小时间片，避免过度上下文切换
        slice.max(MIN_GRANULARITY_NS)
    }
}
```

#### 2.6.4 CFS调度算法

```
算法流程：
1. 选择：总是选择vruntime最小的任务（O(1)，红黑树最左节点）
2. 运行：分配时间片 = SCHED_LATENCY × (weight / total_weight)
3. 更新：运行后更新 vruntime += runtime × (NICE_0_WEIGHT / weight)
4. 抢占：如果有任务vruntime差距超过阈值，触发抢占
```

**配置参数**：

```rust
/// 调度周期：所有任务运行一次的目标时间
pub const SCHED_LATENCY_NS: u64 = 6_000_000;  // 6ms

/// 最小时间片：避免过度上下文切换
pub const MIN_GRANULARITY_NS: u64 = 750_000;  // 0.75ms

/// 抢占粒度：vruntime差异阈值
pub const WAKEUP_GRANULARITY_NS: u64 = 1_000_000;  // 1ms

/// Nice 0 基准权重
pub const NICE_0_WEIGHT: u32 = 1024;
```

**抢占检查**：

```rust
pub fn check_preempt(&self, current_vrt: u64, min_vrt: u64) -> bool {
    // 如果当前任务vruntime超过最小vruntime一定阈值，应该被抢占
    current_vrt.saturating_sub(min_vrt) > WAKEUP_GRANULARITY_NS
}
```

### 2.7 上下文切换

```rust
pub fn suspend_current_and_run_next() {
    // 1. 关中断
    disable_interrupts();
    
    let cpu_id = current_cpu_id();
    let mut processor = PROCESSORS[cpu_id].lock();
    
    // 2. 取出当前任务
    let task = processor.take_current().unwrap();
    
    // 3. 修改状态为 Ready（通过状态机验证）
    let mut task_inner = task.acquire_inner_lock();
    atomic_state_transition(&task, TaskStatus::Running, TaskStatus::Ready).unwrap();
    task_inner.task_status = TaskStatus::Ready;
    let task_cx_ptr = &mut task_inner.task_cx as *mut TaskContext;
    drop(task_inner);
    
    // 4. 放入pending队列（等待下次循环处理）
    processor.set_pending(task);
    
    let idle_cx_ptr = processor.get_idle_task_cx_ptr();
    drop(processor);
    
    // 5. 切换到idle上下文（返回run_tasks循环）
    restore_interrupts();
    unsafe {
        __switch(task_cx_ptr, idle_cx_ptr);
    }
}
```

### 2.8 进程状态机 (state_machine.rs)

**新增功能** (提交: 0efd525)

引入原子状态转换验证，保证多核环境下状态转换的正确性：

```rust
/// 任务状态
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TaskState {
    Ready,           // 就绪
    Running,         // 运行
    Interruptible,   // 可中断睡眠
    Uninterruptible, // 不可中断睡眠
    Stopped,         // 停止
    Zombie,          // 僵尸
}

/// 状态转换验证
pub fn validate_transition(from: TaskState, to: TaskState) -> Result<(), &'static str> {
    use TaskState::*;
    
    match (from, to) {
        // 合法转换
        (Ready, Running) => Ok(()),
        (Running, Ready) => Ok(()),
        (Running, Interruptible) => Ok(()),
        (Running, Uninterruptible) => Ok(()),
        (Running, Zombie) => Ok(()),
        (Interruptible, Ready) => Ok(()),
        (Interruptible, Running) => Ok(()),
        (Uninterruptible, Ready) => Ok(()),
        
        // 非法转换
        _ => Err("Invalid state transition"),
    }
}

/// 原子状态转换
pub fn atomic_state_transition(
    task: &Arc<TaskControlBlock>,
    from: TaskState,
    to: TaskState
) -> Result<(), &'static str> {
    validate_transition(from, to)?;
    
    let mut inner = task.acquire_inner_lock();
    if inner.task_status != from {
        return Err("State mismatch");
    }
    inner.task_status = to;
    
    log::trace!(
        "[Task {}] State transition: {:?} -> {:?}",
        task.pid.0, from, to
    );
    
    Ok(())
}
```

**状态转换图**：

```
         ┌─────────────────────────────────────┐
         │                                     │
         ▼                                     │
    ┌────────┐    schedule    ┌─────────┐     │
    │ Ready  │───────────────▶│ Running │─────┘
    └────┬───┘                └────┬────┘
         ▲                         │
         │                         │
         │                    ┌────┴──────┬──────────────┬────────────┐
         │                    │           │              │            │
         │                    ▼           ▼              ▼            ▼
         │            ┌─────────────┐ ┌──────────┐  ┌─────┐    ┌────────┐
         └────────────│Interruptible│ │Uninterru-│  │Stop │    │ Zombie │
          wake_up     │             │ │ptible    │  │     │    │        │
                      └─────────────┘ └──────────┘  └─────┘    └────────┘
                        sleep/wait     disk I/O     signal     exit()
```

**使用场景**：
- 多核调度时确保状态转换合法性
- 捕获状态机异常，便于调试
- 防止非法状态转换导致的内核panic

### 2.9 信号处理

```rust
/// 信号类型
bitflags! {
    pub struct Signals: u64 {
        const SIGHUP    = 1 << 0;
        const SIGINT    = 1 << 1;
        const SIGQUIT   = 1 << 2;
        const SIGILL    = 1 << 3;
        const SIGTRAP   = 1 << 4;
        const SIGABRT   = 1 << 5;
        const SIGKILL   = 1 << 8;
        // ...
    }
}

/// 信号处理函数
pub struct SigAction {
    pub handler: usize,     // 处理函数地址
    pub flags: SigActionFlags,
    pub mask: Signals,      // 执行时的掩码
}
```

---

## 3. 文件系统模块 (fs)

### 3.1 模块概述

文件系统模块实现了虚拟文件系统 (VFS) 抽象，支持 FAT32 和 EXT4 文件系统，以及各种设备文件。

### 3.2 模块结构

```
os/src/fs/
├── mod.rs              # 模块入口
├── vfs.rs              # 虚拟文件系统
├── file_trait.rs       # File trait 定义
├── file_descriptor.rs  # 文件描述符
├── directory_tree.rs   # 目录树
├── dirent.rs           # 目录项
├── inode.rs            # inode 抽象
├── cache.rs            # 页面缓存
├── layout.rs           # 布局常量
├── poll.rs             # I/O 多路复用
├── timestamp.rs        # 时间戳
├── fat32/              # FAT32 实现
│   ├── mod.rs
│   ├── efs.rs          # EasyFileSystem
│   ├── fat_inode.rs    # FAT inode
│   ├── bitmap.rs       # FAT 表
│   └── layout.rs       # 磁盘布局
├── ext4/               # EXT4 实现
├── dev/                # 设备文件
│   ├── mod.rs
│   ├── pipe.rs         # 管道
│   ├── tty.rs          # 终端
│   ├── null.rs         # /dev/null
│   ├── zero.rs         # /dev/zero
│   └── hwclock.rs      # 硬件时钟
└── swap.rs             # 交换分区
```

### 3.3 核心数据结构

#### 3.3.1 File Trait (file_trait.rs)

```rust
pub trait File: Send + Sync + Downcast {
    /// 是否可读
    fn readable(&self) -> bool;
    
    /// 是否可写
    fn writable(&self) -> bool;
    
    /// 读取数据
    fn read(&self, offset: Option<&mut usize>, buf: &mut [u8]) -> usize;
    
    /// 写入数据
    fn write(&self, offset: Option<&mut usize>, buf: &[u8]) -> usize;
    
    /// 文件定位
    fn seek(&self, offset: isize, whence: SeekWhence) -> usize;
    
    /// 获取文件状态
    fn stat(&self) -> Stat;
    
    /// 在目录中打开文件
    fn open(&self, path: &str, flags: OpenFlags, special: bool) -> Option<Arc<dyn File>>;
    
    /// 获取目录项
    fn getdents(&self, buf: &mut [u8]) -> isize;
    
    /// 获取文件名
    fn get_name(&self) -> String;
    
    /// 是否是目录
    fn is_dir(&self) -> bool;
    
    /// 可读事件
    fn r_ready(&self) -> bool { true }
    
    /// 可写事件
    fn w_ready(&self) -> bool { true }
}
```

#### 3.3.2 文件描述符 (file_descriptor.rs)

```rust
pub struct FileDescriptor {
    cloexec: bool,
    nonblock: bool,
    inner: Arc<dyn File>,
    offset: Mutex<usize>,
}

/// 文件描述符表
pub struct FdTable {
    table: Vec<Option<FileDescriptor>>,
}

impl FdTable {
    pub fn alloc(&mut self) -> Option<usize>;
    pub fn get(&self, fd: usize) -> Option<&FileDescriptor>;
    pub fn insert(&mut self, fd: FileDescriptor) -> Option<usize>;
    pub fn remove(&mut self, fd: usize) -> Option<FileDescriptor>;
}
```

#### 3.3.3 打开标志

```rust
bitflags! {
    pub struct OpenFlags: u32 {
        const O_RDONLY    = 0;
        const O_WRONLY    = 1 << 0;
        const O_RDWR      = 1 << 1;
        const O_CREAT     = 1 << 6;
        const O_EXCL      = 1 << 7;
        const O_TRUNC     = 1 << 9;
        const O_APPEND    = 1 << 10;
        const O_NONBLOCK  = 1 << 11;
        const O_DIRECTORY = 1 << 16;
        const O_CLOEXEC   = 1 << 19;
    }
}
```

### 3.4 页面缓存 (cache.rs)

```rust
/// 块缓存
pub struct BlockCache {
    data: [u8; BLOCK_SIZE],
    block_id: usize,
    modified: bool,
}

/// 页面缓存管理器
pub struct PageCacheManager {
    cache: BTreeMap<usize, Arc<Mutex<PageCache>>>,
}
```

### 3.5 FAT32 实现

```rust
/// FAT32 文件系统
pub struct EasyFileSystem {
    pub block_device: Arc<dyn BlockDevice>,
    pub fat: Fat,
    pub root_cluster: u32,
    pub bytes_per_cluster: usize,
}

/// FAT inode
pub struct FatInode {
    fs: Arc<EasyFileSystem>,
    cluster: u32,
    size: usize,
    inode_type: DiskInodeType,
}
```

---

## 4. 系统调用模块 (syscall)

### 4.1 模块概述

系统调用模块实现了与 Linux 兼容的系统调用接口，是用户态与内核态的桥梁。

### 4.2 模块结构

```
os/src/syscall/
├── mod.rs          # 系统调用分发
├── syscall_id.rs   # 系统调用号定义
├── syscall_macro.rs # 宏定义
├── errno.rs        # 错误码
├── fs.rs           # 文件系统相关
├── process.rs      # 进程相关
└── net.rs          # 网络相关
```

### 4.3 系统调用分发

```rust
pub fn syscall(syscall_id: usize, args: [usize; 6]) -> isize {
    match syscall_id {
        // 文件系统
        SYSCALL_READ => sys_read(args[0], args[1] as *mut u8, args[2]),
        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),
        SYSCALL_OPENAT => sys_openat(args[0] as isize, args[1] as *const u8, args[2], args[3]),
        SYSCALL_CLOSE => sys_close(args[0]),
        
        // 进程管理
        SYSCALL_EXIT => sys_exit(args[0] as u32),
        SYSCALL_CLONE => sys_clone(args[0], args[1], args[2], args[3], args[4]),
        SYSCALL_EXECVE => sys_execve(args[0] as *const u8, args[1] as *const usize, args[2] as *const usize),
        SYSCALL_WAIT4 => sys_wait4(args[0] as isize, args[1] as *mut i32, args[2] as u32),
        
        // 内存管理
        SYSCALL_MMAP => sys_mmap(args[0], args[1], args[2], args[3], args[4] as i32, args[5]),
        SYSCALL_MUNMAP => sys_munmap(args[0], args[1]),
        SYSCALL_BRK => sys_brk(args[0]),
        
        // ... 更多系统调用
        _ => panic!("Unsupported syscall: {}", syscall_id),
    }
}
```

### 4.4 主要系统调用

#### 4.4.1 进程管理

| 系统调用 | 编号 | 功能 |
|---------|------|------|
| exit | 93 | 进程退出 |
| exit_group | 94 | 线程组退出 |
| clone | 220 | 创建进程/线程 |
| execve | 221 | 执行程序 |
| wait4 | 260 | 等待子进程 |
| getpid | 172 | 获取进程 ID |
| getppid | 173 | 获取父进程 ID |
| gettid | 178 | 获取线程 ID |

#### 4.4.2 文件操作

| 系统调用 | 编号 | 功能 |
|---------|------|------|
| openat | 56 | 打开文件 |
| close | 57 | 关闭文件 |
| read | 63 | 读取文件 |
| write | 64 | 写入文件 |
| lseek | 62 | 文件定位 |
| dup/dup3 | 23/20 | 复制文件描述符 |
| pipe2 | 59 | 创建管道 |
| fstat | 80 | 获取文件状态 |

#### 4.4.3 内存管理

| 系统调用 | 编号 | 功能 |
|---------|------|------|
| brk | 214 | 调整堆大小 |
| mmap | 222 | 内存映射 |
| munmap | 215 | 取消映射 |
| mprotect | 226 | 修改权限 |

### 4.5 错误码 (errno.rs)

```rust
pub const EPERM: isize = -1;      // 操作不允许
pub const ENOENT: isize = -2;     // 文件不存在
pub const ESRCH: isize = -3;      // 进程不存在
pub const EINTR: isize = -4;      // 系统调用中断
pub const EIO: isize = -5;        // I/O 错误
pub const EBADF: isize = -9;      // 文件描述符无效
pub const EAGAIN: isize = -11;    // 资源暂不可用
pub const ENOMEM: isize = -12;    // 内存不足
pub const EACCES: isize = -13;    // 权限不足
pub const EFAULT: isize = -14;    // 地址无效
pub const EEXIST: isize = -17;    // 文件已存在
pub const ENOTDIR: isize = -20;   // 不是目录
pub const EISDIR: isize = -21;    // 是目录
pub const EINVAL: isize = -22;    // 参数无效
// ... 更多错误码
```

---

## 5. 设备驱动模块 (drivers)

### 5.1 模块概述

设备驱动模块提供块设备和字符设备的抽象和实现。

### 5.2 模块结构

```
os/src/drivers/
├── mod.rs          # 模块入口
├── block/          # 块设备
│   ├── mod.rs
│   ├── block_dev.rs    # BlockDevice trait
│   ├── mem_blk.rs      # 内存块设备
│   ├── sata_blk.rs     # SATA 块设备
│   ├── virtio_blk.rs   # VirtIO 块设备
│   └── virtio_blk_pci.rs
└── serial/         # 串口设备
    ├── mod.rs
    └── ns16550a.rs # NS16550A UART
```

### 5.3 块设备抽象

```rust
/// 块设备 trait
pub trait BlockDevice: Send + Sync {
    fn read_block(&self, block_id: usize, buf: &mut [u8]);
    fn write_block(&self, block_id: usize, buf: &[u8]);
}

// 全局块设备
lazy_static! {
    pub static ref BLOCK_DEVICE: Arc<dyn BlockDevice> = Arc::new(BlockDeviceImpl::new());
}
```

### 5.4 VirtIO 块设备

```rust
pub struct VirtIOBlock {
    virtio_blk: Mutex<VirtIOBlk<'static, HalImpl>>,
}

impl BlockDevice for VirtIOBlock {
    fn read_block(&self, block_id: usize, buf: &mut [u8]) {
        self.virtio_blk.lock()
            .read_block(block_id, buf)
            .expect("VirtIO read error");
    }
    
    fn write_block(&self, block_id: usize, buf: &[u8]) {
        self.virtio_blk.lock()
            .write_block(block_id, buf)
            .expect("VirtIO write error");
    }
}
```

---

## 6. 网络模块 (net)

### 6.1 模块概述

网络模块基于 smoltcp 协议栈实现 TCP/UDP Socket 接口。

### 6.2 模块结构

```
os/src/net/
├── mod.rs          # 模块入口
├── config.rs       # 网络配置
├── address.rs      # 地址处理
├── tcp.rs          # TCP Socket
├── udp.rs          # UDP Socket
└── unix.rs         # Unix Socket
```

### 6.3 Socket 抽象

```rust
pub trait Socket: File {
    fn bind(&self, addr: IpListenEndpoint) -> SyscallRet;
    fn listen(&self) -> SyscallRet;
    fn connect<'a>(&'a self, addr_buf: &'a [u8]) -> SyscallRet;
    fn accept(&self, sockfd: u32, addr: usize, addrlen: usize) -> SyscallRet;
    fn socket_type(&self) -> SocketType;
    fn recv_buf_size(&self) -> usize;
    fn send_buf_size(&self) -> usize;
    fn loacl_endpoint(&self) -> IpListenEndpoint;
    fn remote_endpoint(&self) -> Option<IpEndpoint>;
    fn shutdown(&self, how: u32) -> GeneralRet<()>;
}
```

### 6.4 TCP Socket 实现

```rust
pub struct TcpSocket {
    inner: Mutex<TcpSocketInner>,
}

struct TcpSocketInner {
    state: TcpState,
    local_endpoint: IpListenEndpoint,
    remote_endpoint: Option<IpEndpoint>,
    recv_buffer: VecDeque<u8>,
    send_buffer: VecDeque<u8>,
}
```

---

## 7. 工具模块 (utils)

### 7.1 错误处理

```rust
pub type SyscallRet = Result<usize, SyscallErr>;
pub type GeneralRet<T> = Result<T, SyscallErr>;

pub enum SyscallErr {
    EPERM,
    ENOENT,
    ESRCH,
    // ...
}
```

### 7.2 日志系统

使用 `log` crate 实现分级日志:

```rust
// 日志级别由 feature 控制
// log_off, log_error, log_warn, log_info

log::trace!("详细信息");
log::debug!("调试信息");
log::info!("一般信息");
log::warn!("警告信息");
log::error!("错误信息");
```

---

## 8. 内核错误处理框架 (utils/kerror.rs)

### 8.1 概述

**新增功能** (提交: fb5601d)

统一的内核错误处理框架，提供类型安全的错误传播和上下文信息：

```rust
/// 内核错误类型
#[derive(Debug)]
pub enum KernelError {
    /// 系统调用错误
    Syscall(SyscallError),
    /// 内存管理错误
    Memory(MemoryError),
    /// 文件系统错误
    FileSystem(FsError),
    /// 进程管理错误
    Process(ProcessError),
    /// 设备驱动错误
    Device(DeviceError),
    /// 网络错误
    Network(NetworkError),
}

/// 系统调用错误码
#[derive(Debug, Clone, Copy)]
pub enum SyscallError {
    EPERM,      // 操作不允许
    ENOENT,     // 文件/目录不存在
    ESRCH,      // 进程不存在
    EINTR,      // 中断的系统调用
    EIO,        // I/O错误
    ENOMEM,     // 内存不足
    EACCES,     // 权限拒绝
    EFAULT,     // 地址错误
    EEXIST,     // 文件已存在
    EINVAL,     // 无效参数
    // ... 更多错误码
}

impl SyscallError {
    /// 转换为 errno 值
    pub fn errno(&self) -> isize {
        match self {
            Self::EPERM => -1,
            Self::ENOENT => -2,
            Self::ESRCH => -3,
            // ...
        }
    }
}
```

### 8.2 错误上下文

```rust
/// 带上下文的错误
pub struct ErrorContext {
    pub error: KernelError,
    pub location: &'static str,
    pub message: String,
}

/// 错误宏
#[macro_export]
macro_rules! kerror {
    ($err:expr, $msg:expr) => {
        ErrorContext {
            error: $err,
            location: concat!(file!(), ":", line!()),
            message: format!($msg),
        }
    };
}
```

### 8.3 使用示例

```rust
pub fn sys_open(path: &str, flags: OpenFlags) -> Result<usize, KernelError> {
    let file = open_file(path, flags)
        .map_err(|e| kerror!(
            KernelError::FileSystem(FsError::NotFound),
            "Failed to open file: {}", path
        ))?;
    
    Ok(alloc_fd(file))
}
```

---

## 9. 诊断与指标模块 (utils/trace.rs)

### 9.1 概述

**新增功能** (提交: a69db7c)

提供系统运行时诊断和性能指标收集：

```rust
/// 性能指标
pub struct SystemMetrics {
    /// 上下文切换次数
    pub context_switches: AtomicU64,
    /// 页面错误次数
    pub page_faults: AtomicU64,
    /// 系统调用次数
    pub syscalls: AtomicU64,
    /// 中断次数
    pub interrupts: AtomicU64,
}

lazy_static! {
    pub static ref METRICS: SystemMetrics = SystemMetrics::new();
}
```

### 9.2 性能追踪

```rust
/// 追踪系统调用
#[macro_export]
macro_rules! trace_syscall {
    ($name:expr, $body:block) => {{
        METRICS.syscalls.fetch_add(1, Ordering::Relaxed);
        let start = get_time_ns();
        let result = $body;
        let duration = get_time_ns() - start;
        
        if duration > SLOW_SYSCALL_THRESHOLD {
            log::warn!("Slow syscall {}: {}ns", $name, duration);
        }
        result
    }};
}
```

### 9.3 诊断信息

```rust
/// 获取系统诊断信息
pub fn get_diagnostics() -> DiagnosticsInfo {
    DiagnosticsInfo {
        uptime: get_uptime(),
        memory_usage: get_memory_usage(),
        cpu_usage: get_cpu_usage(),
        task_count: get_task_count(),
        metrics: METRICS.snapshot(),
    }
}
```

---

## 10. 系统调用上下文模式 (syscall/dispatch.rs)

### 10.1 概述

**新增功能** (提交: 8d43a22)

引入 SyscallContext 模式，统一管理系统调用的上下文信息：

```rust
/// 系统调用上下文
pub struct SyscallContext {
    /// 当前任务
    pub task: Arc<TaskControlBlock>,
    /// 陷阱上下文
    pub trap_cx: &'static mut TrapContext,
    /// CPU ID
    pub cpu_id: usize,
    /// 系统调用号
    pub syscall_id: usize,
}

impl SyscallContext {
    /// 获取系统调用参数
    pub fn args(&self) -> [usize; 6] {
        [
            self.trap_cx.x[10], // a0
            self.trap_cx.x[11], // a1
            self.trap_cx.x[12], // a2
            self.trap_cx.x[13], // a3
            self.trap_cx.x[14], // a4
            self.trap_cx.x[15], // a5
        ]
    }
    
    /// 设置返回值
    pub fn set_return(&mut self, value: isize) {
        self.trap_cx.x[10] = value as usize;
    }
    
    /// 用户空间指针验证
    pub fn check_ptr<T>(&self, ptr: *const T) -> Result<(), SyscallError> {
        let vaddr = VirtAddr::from(ptr as usize);
        self.task.check_user_pointer(vaddr)?;
        Ok(())
    }
}
```

### 10.2 系统调用分发

```rust
pub fn syscall(syscall_id: usize, args: [usize; 6]) -> isize {
    let task = current_task().unwrap();
    let trap_cx = current_trap_cx();
    let cpu_id = current_cpu_id();
    
    let mut ctx = SyscallContext {
        task,
        trap_cx,
        cpu_id,
        syscall_id,
    };
    
    // 追踪和分发
    trace_syscall!(syscall_id, {
        match syscall_id {
            SYSCALL_WRITE => sys_write(&mut ctx, args[0], args[1], args[2]),
            SYSCALL_READ => sys_read(&mut ctx, args[0], args[1], args[2]),
            SYSCALL_OPENAT => sys_openat(&mut ctx, args[0], args[1], args[2], args[3]),
            // ... 更多系统调用
            _ => {
                log::warn!("Unsupported syscall: {}", syscall_id);
                -ENOSYS
            }
        }
    })
}
```

---

## 11. 内存分配策略优化 (mm/frame_allocator.rs)

### 11.1 Next-Fit分配器

**新增功能** (提交: 23d3436)

替代原有的位图分配器，采用 next-fit 策略提升分配效率：

```rust
/// Next-Fit 帧分配器
pub struct NextFitAllocator {
    /// 空闲页帧链表
    free_list: LinkedList<FrameRange>,
    /// 上次分配位置（next-fit游标）
    last_alloc: PhysPageNum,
    /// 总空闲帧数
    free_frames: usize,
}

impl NextFitAllocator {
    /// 分配物理页帧
    pub fn alloc(&mut self) -> Option<PhysPageNum> {
        // 从上次分配位置开始查找
        let start_pos = self.last_alloc;
        
        for range in &mut self.free_list {
            if range.start >= start_pos && !range.is_empty() {
                let ppn = range.alloc_one();
                self.last_alloc = ppn;
                self.free_frames -= 1;
                return Some(ppn);
            }
        }
        
        // 回绕到开头继续查找
        for range in &mut self.free_list {
            if range.start < start_pos && !range.is_empty() {
                let ppn = range.alloc_one();
                self.last_alloc = ppn;
                self.free_frames -= 1;
                return Some(ppn);
            }
        }
        
        None
    }
}
```

**优势**：
- 减少内存碎片
- 提升分配速度
- 更好的缓存局部性

---

*文档版本: 2.0*  
*最后更新: 2026年1月 (多核与调度框架更新)*
