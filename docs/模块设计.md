# NPUcore-Ovo 模块设计文档

## 1. 内存管理模块 (mm)

### 1.1 模块概述

内存管理模块负责管理系统的物理内存和虚拟内存，提供地址空间抽象、页表管理、物理页帧分配等核心功能。

### 1.2 模块结构

```
os/src/mm/
├── mod.rs              # 模块入口，导出公共接口
├── address.rs          # 地址类型定义
├── page_table.rs       # 页表操作
├── frame_allocator.rs  # 物理页帧分配器
├── heap_allocator.rs   # 内核堆分配器
├── memory_set.rs       # 地址空间管理
├── map_area.rs         # 内存映射区域
└── zram.rs             # ZRAM 压缩内存
```

### 1.3 核心数据结构

#### 1.3.1 地址类型 (address.rs)

```rust
/// 物理地址
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysAddr(pub usize);

/// 虚拟地址
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtAddr(pub usize);

/// 物理页号
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct PhysPageNum(pub usize);

/// 虚拟页号
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
pub struct VirtPageNum(pub usize);
```

#### 1.3.2 页帧分配器 (frame_allocator.rs)

```rust
/// 物理页帧追踪器 (RAII)
pub struct FrameTracker {
    pub ppn: PhysPageNum,
}

impl Drop for FrameTracker {
    fn drop(&mut self) {
        frame_dealloc(self.ppn);
    }
}

// 公共接口
pub fn frame_alloc() -> Option<FrameTracker>;
pub fn frames_alloc(num: usize) -> Option<Vec<FrameTracker>>;
pub fn frame_dealloc(ppn: PhysPageNum);
pub fn unallocated_frames() -> usize;
```

#### 1.3.3 地址空间 (memory_set.rs)

```rust
/// 内存集合，表示一个地址空间
pub struct MemorySet<T: PageTable> {
    page_table: T,
    areas: Vec<MapArea>,
}

impl<T: PageTable> MemorySet<T> {
    /// 创建内核空间
    pub fn new_kernel() -> Self;
    
    /// 创建用户空间
    pub fn new_bare() -> Self;
    
    /// 插入匿名映射区域
    pub fn insert_framed_area(&mut self, start: VirtAddr, end: VirtAddr, perm: MapPermission);
    
    /// mmap 系统调用实现
    pub fn mmap(&mut self, start: VirtAddr, len: usize, prot: usize, flags: usize) -> Result<usize>;
    
    /// 复制地址空间 (fork)
    pub fn from_copy_on_write(another: &mut MemorySet<T>) -> Self;
}
```

#### 1.3.4 内存映射区域 (map_area.rs)

```rust
/// 映射类型
pub enum MapType {
    Identical,  // 恒等映射 (PA == VA)
    Framed,     // 分帧映射
    Linear,     // 线性映射
}

/// 映射权限
bitflags! {
    pub struct MapPermission: u8 {
        const R = 1 << 1;  // 可读
        const W = 1 << 2;  // 可写
        const X = 1 << 3;  // 可执行
        const U = 1 << 4;  // 用户态可访问
    }
}

/// 内存映射区域
pub struct MapArea {
    pub inner: MapAreaInner,
}

pub struct MapAreaInner {
    pub vpn_range: VPNRange,
    pub map_type: MapType,
    pub permission: MapPermission,
    pub frames: Vec<Frame>,
}
```

### 1.4 初始化流程

```rust
pub fn init() {
    // 1. 初始化内核堆
    heap_allocator::init_heap();
    
    // 2. 初始化物理页帧分配器
    frame_allocator::init_frame_allocator();
    
    // 3. 激活内核页表
    KERNEL_SPACE.lock().activate();
}
```

### 1.5 关键功能

| 功能 | 函数 | 描述 |
|------|------|------|
| 页帧分配 | `frame_alloc()` | 分配单个物理页帧 |
| 批量分配 | `frames_alloc(n)` | 分配连续 n 个页帧 |
| 地址翻译 | `translate()` | 虚拟地址到物理地址转换 |
| 用户缓冲区 | `translated_byte_buffer()` | 安全访问用户空间 |
| 写时复制 | `copy_on_write()` | 处理 CoW 页面错误 |

---

## 2. 进程管理模块 (task)

### 2.1 模块概述

进程管理模块负责任务的创建、调度、同步和销毁，实现了进程和线程的统一抽象。

### 2.2 模块结构

```
os/src/task/
├── mod.rs          # 模块入口
├── task.rs         # 任务控制块定义
├── manager.rs      # 任务管理器/调度器
├── processor.rs    # 处理器抽象
├── context.rs      # 任务上下文
├── pid.rs          # PID 分配器
├── signal.rs       # 信号处理
├── threads.rs      # 线程同步 (Futex)
└── elf.rs          # ELF 加载器
```

### 2.3 核心数据结构

#### 2.3.1 任务控制块 (task.rs)

```rust
pub struct TaskControlBlock {
    // === 不可变字段 ===
    pub pid: PidHandle,           // 进程 ID
    pub tid: usize,               // 线程 ID  
    pub tgid: usize,              // 线程组 ID
    pub kstack: KernelStack,      // 内核栈
    pub ustack_base: usize,       // 用户栈基址
    pub exit_signal: Signals,     // 退出信号
    
    // === 可变字段 (Mutex) ===
    inner: Mutex<TaskControlBlockInner>,
    
    // === 可共享字段 ===
    pub exe: Arc<Mutex<FileDescriptor>>,
    pub tid_allocator: Arc<Mutex<RecycleAllocator>>,
    pub files: Arc<Mutex<FdTable>>,
    pub socket_table: Arc<Mutex<SocketTable>>,
    pub fs: Arc<Mutex<FsStatus>>,
    pub vm: Arc<Mutex<MemorySet>>,
    pub sighand: Arc<Mutex<Vec<Option<Box<SigAction>>>>>,
    pub futex: Arc<Mutex<Futex>>,
}

pub struct TaskControlBlockInner {
    pub sigmask: Signals,         // 信号掩码
    pub sigpending: Signals,      // 待处理信号
    pub trap_cx_ppn: PhysPageNum, // 陷阱上下文
    pub task_cx: TaskContext,     // 任务上下文
    pub task_status: TaskStatus,  // 任务状态
    pub parent: Option<Weak<TaskControlBlock>>,
    pub children: Vec<Arc<TaskControlBlock>>,
    pub exit_code: u32,           // 退出码
    pub heap_bottom: usize,       // 堆底
    pub rusage: Rusage,           // 资源使用
}
```

#### 2.3.2 任务状态

```rust
#[derive(Copy, Clone, PartialEq)]
pub enum TaskStatus {
    Ready,          // 就绪态
    Running,        // 运行态
    Interruptible,  // 可中断睡眠
    Zombie,         // 僵尸态
}
```

#### 2.3.3 任务上下文 (context.rs)

```rust
#[repr(C)]
pub struct TaskContext {
    ra: usize,      // 返回地址
    sp: usize,      // 栈指针
    s: [usize; 12], // 被调用者保存寄存器
}
```

#### 2.3.4 任务管理器 (manager.rs)

```rust
pub struct TaskManager {
    pub ready_queue: VecDeque<Arc<TaskControlBlock>>,
    pub interruptible_queue: VecDeque<Arc<TaskControlBlock>>,
    #[cfg(feature = "oom_handler")]
    pub active_tracker: ActiveTracker,
}

// 全局任务管理器 (每 CPU 一个)
lazy_static! {
    pub static ref TASK_MANAGERS: [Mutex<TaskManager>; MAX_CPU_NUM] = ...;
}
```

### 2.4 调度算法

当前实现简单的时间片轮转 (Round-Robin):

```rust
pub fn fetch_task() -> Option<Arc<TaskControlBlock>> {
    let cpu_id = current_cpu_id();
    let mut manager = TASK_MANAGERS[cpu_id].lock();
    manager.ready_queue.pop_front()
}

pub fn add_task(task: Arc<TaskControlBlock>) {
    let cpu_id = current_cpu_id();
    TASK_MANAGERS[cpu_id].lock().ready_queue.push_back(task);
}
```

### 2.5 上下文切换

```rust
pub fn suspend_current_and_run_next() {
    // 1. 关中断
    unsafe { sstatus::clear_sie(); }
    
    // 2. 取出当前任务
    let task = take_current_task().unwrap();
    
    // 3. 修改状态为 Ready
    let mut task_inner = task.acquire_inner_lock();
    task_inner.task_status = TaskStatus::Ready;
    let task_cx_ptr = &mut task_inner.task_cx as *mut TaskContext;
    drop(task_inner);
    
    // 4. 加入就绪队列
    add_task(task);
    
    // 5. 调度下一个任务
    schedule(task_cx_ptr);
}
```

### 2.6 信号处理

```rust
/// 信号类型
bitflags! {
    pub struct Signals: u64 {
        const SIGHUP    = 1 << 0;
        const SIGINT    = 1 << 1;
        const SIGQUIT   = 1 << 2;
        const SIGILL    = 1 << 3;
        const SIGTRAP   = 1 << 4;
        const SIGABRT   = 1 << 5;
        const SIGKILL   = 1 << 8;
        // ...
    }
}

/// 信号处理函数
pub struct SigAction {
    pub handler: usize,     // 处理函数地址
    pub flags: SigActionFlags,
    pub mask: Signals,      // 执行时的掩码
}
```

---

## 3. 文件系统模块 (fs)

### 3.1 模块概述

文件系统模块实现了虚拟文件系统 (VFS) 抽象，支持 FAT32 和 EXT4 文件系统，以及各种设备文件。

### 3.2 模块结构

```
os/src/fs/
├── mod.rs              # 模块入口
├── vfs.rs              # 虚拟文件系统
├── file_trait.rs       # File trait 定义
├── file_descriptor.rs  # 文件描述符
├── directory_tree.rs   # 目录树
├── dirent.rs           # 目录项
├── inode.rs            # inode 抽象
├── cache.rs            # 页面缓存
├── layout.rs           # 布局常量
├── poll.rs             # I/O 多路复用
├── timestamp.rs        # 时间戳
├── fat32/              # FAT32 实现
│   ├── mod.rs
│   ├── efs.rs          # EasyFileSystem
│   ├── fat_inode.rs    # FAT inode
│   ├── bitmap.rs       # FAT 表
│   └── layout.rs       # 磁盘布局
├── ext4/               # EXT4 实现
├── dev/                # 设备文件
│   ├── mod.rs
│   ├── pipe.rs         # 管道
│   ├── tty.rs          # 终端
│   ├── null.rs         # /dev/null
│   ├── zero.rs         # /dev/zero
│   └── hwclock.rs      # 硬件时钟
└── swap.rs             # 交换分区
```

### 3.3 核心数据结构

#### 3.3.1 File Trait (file_trait.rs)

```rust
pub trait File: Send + Sync + Downcast {
    /// 是否可读
    fn readable(&self) -> bool;
    
    /// 是否可写
    fn writable(&self) -> bool;
    
    /// 读取数据
    fn read(&self, offset: Option<&mut usize>, buf: &mut [u8]) -> usize;
    
    /// 写入数据
    fn write(&self, offset: Option<&mut usize>, buf: &[u8]) -> usize;
    
    /// 文件定位
    fn seek(&self, offset: isize, whence: SeekWhence) -> usize;
    
    /// 获取文件状态
    fn stat(&self) -> Stat;
    
    /// 在目录中打开文件
    fn open(&self, path: &str, flags: OpenFlags, special: bool) -> Option<Arc<dyn File>>;
    
    /// 获取目录项
    fn getdents(&self, buf: &mut [u8]) -> isize;
    
    /// 获取文件名
    fn get_name(&self) -> String;
    
    /// 是否是目录
    fn is_dir(&self) -> bool;
    
    /// 可读事件
    fn r_ready(&self) -> bool { true }
    
    /// 可写事件
    fn w_ready(&self) -> bool { true }
}
```

#### 3.3.2 文件描述符 (file_descriptor.rs)

```rust
pub struct FileDescriptor {
    cloexec: bool,
    nonblock: bool,
    inner: Arc<dyn File>,
    offset: Mutex<usize>,
}

/// 文件描述符表
pub struct FdTable {
    table: Vec<Option<FileDescriptor>>,
}

impl FdTable {
    pub fn alloc(&mut self) -> Option<usize>;
    pub fn get(&self, fd: usize) -> Option<&FileDescriptor>;
    pub fn insert(&mut self, fd: FileDescriptor) -> Option<usize>;
    pub fn remove(&mut self, fd: usize) -> Option<FileDescriptor>;
}
```

#### 3.3.3 打开标志

```rust
bitflags! {
    pub struct OpenFlags: u32 {
        const O_RDONLY    = 0;
        const O_WRONLY    = 1 << 0;
        const O_RDWR      = 1 << 1;
        const O_CREAT     = 1 << 6;
        const O_EXCL      = 1 << 7;
        const O_TRUNC     = 1 << 9;
        const O_APPEND    = 1 << 10;
        const O_NONBLOCK  = 1 << 11;
        const O_DIRECTORY = 1 << 16;
        const O_CLOEXEC   = 1 << 19;
    }
}
```

### 3.4 页面缓存 (cache.rs)

```rust
/// 块缓存
pub struct BlockCache {
    data: [u8; BLOCK_SIZE],
    block_id: usize,
    modified: bool,
}

/// 页面缓存管理器
pub struct PageCacheManager {
    cache: BTreeMap<usize, Arc<Mutex<PageCache>>>,
}
```

### 3.5 FAT32 实现

```rust
/// FAT32 文件系统
pub struct EasyFileSystem {
    pub block_device: Arc<dyn BlockDevice>,
    pub fat: Fat,
    pub root_cluster: u32,
    pub bytes_per_cluster: usize,
}

/// FAT inode
pub struct FatInode {
    fs: Arc<EasyFileSystem>,
    cluster: u32,
    size: usize,
    inode_type: DiskInodeType,
}
```

---

## 4. 系统调用模块 (syscall)

### 4.1 模块概述

系统调用模块实现了与 Linux 兼容的系统调用接口，是用户态与内核态的桥梁。

### 4.2 模块结构

```
os/src/syscall/
├── mod.rs          # 系统调用分发
├── syscall_id.rs   # 系统调用号定义
├── syscall_macro.rs # 宏定义
├── errno.rs        # 错误码
├── fs.rs           # 文件系统相关
├── process.rs      # 进程相关
└── net.rs          # 网络相关
```

### 4.3 系统调用分发

```rust
pub fn syscall(syscall_id: usize, args: [usize; 6]) -> isize {
    match syscall_id {
        // 文件系统
        SYSCALL_READ => sys_read(args[0], args[1] as *mut u8, args[2]),
        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),
        SYSCALL_OPENAT => sys_openat(args[0] as isize, args[1] as *const u8, args[2], args[3]),
        SYSCALL_CLOSE => sys_close(args[0]),
        
        // 进程管理
        SYSCALL_EXIT => sys_exit(args[0] as u32),
        SYSCALL_CLONE => sys_clone(args[0], args[1], args[2], args[3], args[4]),
        SYSCALL_EXECVE => sys_execve(args[0] as *const u8, args[1] as *const usize, args[2] as *const usize),
        SYSCALL_WAIT4 => sys_wait4(args[0] as isize, args[1] as *mut i32, args[2] as u32),
        
        // 内存管理
        SYSCALL_MMAP => sys_mmap(args[0], args[1], args[2], args[3], args[4] as i32, args[5]),
        SYSCALL_MUNMAP => sys_munmap(args[0], args[1]),
        SYSCALL_BRK => sys_brk(args[0]),
        
        // ... 更多系统调用
        _ => panic!("Unsupported syscall: {}", syscall_id),
    }
}
```

### 4.4 主要系统调用

#### 4.4.1 进程管理

| 系统调用 | 编号 | 功能 |
|---------|------|------|
| exit | 93 | 进程退出 |
| exit_group | 94 | 线程组退出 |
| clone | 220 | 创建进程/线程 |
| execve | 221 | 执行程序 |
| wait4 | 260 | 等待子进程 |
| getpid | 172 | 获取进程 ID |
| getppid | 173 | 获取父进程 ID |
| gettid | 178 | 获取线程 ID |

#### 4.4.2 文件操作

| 系统调用 | 编号 | 功能 |
|---------|------|------|
| openat | 56 | 打开文件 |
| close | 57 | 关闭文件 |
| read | 63 | 读取文件 |
| write | 64 | 写入文件 |
| lseek | 62 | 文件定位 |
| dup/dup3 | 23/20 | 复制文件描述符 |
| pipe2 | 59 | 创建管道 |
| fstat | 80 | 获取文件状态 |

#### 4.4.3 内存管理

| 系统调用 | 编号 | 功能 |
|---------|------|------|
| brk | 214 | 调整堆大小 |
| mmap | 222 | 内存映射 |
| munmap | 215 | 取消映射 |
| mprotect | 226 | 修改权限 |

### 4.5 错误码 (errno.rs)

```rust
pub const EPERM: isize = -1;      // 操作不允许
pub const ENOENT: isize = -2;     // 文件不存在
pub const ESRCH: isize = -3;      // 进程不存在
pub const EINTR: isize = -4;      // 系统调用中断
pub const EIO: isize = -5;        // I/O 错误
pub const EBADF: isize = -9;      // 文件描述符无效
pub const EAGAIN: isize = -11;    // 资源暂不可用
pub const ENOMEM: isize = -12;    // 内存不足
pub const EACCES: isize = -13;    // 权限不足
pub const EFAULT: isize = -14;    // 地址无效
pub const EEXIST: isize = -17;    // 文件已存在
pub const ENOTDIR: isize = -20;   // 不是目录
pub const EISDIR: isize = -21;    // 是目录
pub const EINVAL: isize = -22;    // 参数无效
// ... 更多错误码
```

---

## 5. 设备驱动模块 (drivers)

### 5.1 模块概述

设备驱动模块提供块设备和字符设备的抽象和实现。

### 5.2 模块结构

```
os/src/drivers/
├── mod.rs          # 模块入口
├── block/          # 块设备
│   ├── mod.rs
│   ├── block_dev.rs    # BlockDevice trait
│   ├── mem_blk.rs      # 内存块设备
│   ├── sata_blk.rs     # SATA 块设备
│   ├── virtio_blk.rs   # VirtIO 块设备
│   └── virtio_blk_pci.rs
└── serial/         # 串口设备
    ├── mod.rs
    └── ns16550a.rs # NS16550A UART
```

### 5.3 块设备抽象

```rust
/// 块设备 trait
pub trait BlockDevice: Send + Sync {
    fn read_block(&self, block_id: usize, buf: &mut [u8]);
    fn write_block(&self, block_id: usize, buf: &[u8]);
}

// 全局块设备
lazy_static! {
    pub static ref BLOCK_DEVICE: Arc<dyn BlockDevice> = Arc::new(BlockDeviceImpl::new());
}
```

### 5.4 VirtIO 块设备

```rust
pub struct VirtIOBlock {
    virtio_blk: Mutex<VirtIOBlk<'static, HalImpl>>,
}

impl BlockDevice for VirtIOBlock {
    fn read_block(&self, block_id: usize, buf: &mut [u8]) {
        self.virtio_blk.lock()
            .read_block(block_id, buf)
            .expect("VirtIO read error");
    }
    
    fn write_block(&self, block_id: usize, buf: &[u8]) {
        self.virtio_blk.lock()
            .write_block(block_id, buf)
            .expect("VirtIO write error");
    }
}
```

---

## 6. 网络模块 (net)

### 6.1 模块概述

网络模块基于 smoltcp 协议栈实现 TCP/UDP Socket 接口。

### 6.2 模块结构

```
os/src/net/
├── mod.rs          # 模块入口
├── config.rs       # 网络配置
├── address.rs      # 地址处理
├── tcp.rs          # TCP Socket
├── udp.rs          # UDP Socket
└── unix.rs         # Unix Socket
```

### 6.3 Socket 抽象

```rust
pub trait Socket: File {
    fn bind(&self, addr: IpListenEndpoint) -> SyscallRet;
    fn listen(&self) -> SyscallRet;
    fn connect<'a>(&'a self, addr_buf: &'a [u8]) -> SyscallRet;
    fn accept(&self, sockfd: u32, addr: usize, addrlen: usize) -> SyscallRet;
    fn socket_type(&self) -> SocketType;
    fn recv_buf_size(&self) -> usize;
    fn send_buf_size(&self) -> usize;
    fn loacl_endpoint(&self) -> IpListenEndpoint;
    fn remote_endpoint(&self) -> Option<IpEndpoint>;
    fn shutdown(&self, how: u32) -> GeneralRet<()>;
}
```

### 6.4 TCP Socket 实现

```rust
pub struct TcpSocket {
    inner: Mutex<TcpSocketInner>,
}

struct TcpSocketInner {
    state: TcpState,
    local_endpoint: IpListenEndpoint,
    remote_endpoint: Option<IpEndpoint>,
    recv_buffer: VecDeque<u8>,
    send_buffer: VecDeque<u8>,
}
```

---

## 7. 工具模块 (utils)

### 7.1 错误处理

```rust
pub type SyscallRet = Result<usize, SyscallErr>;
pub type GeneralRet<T> = Result<T, SyscallErr>;

pub enum SyscallErr {
    EPERM,
    ENOENT,
    ESRCH,
    // ...
}
```

### 7.2 日志系统

使用 `log` crate 实现分级日志:

```rust
// 日志级别由 feature 控制
// log_off, log_error, log_warn, log_info

log::trace!("详细信息");
log::debug!("调试信息");
log::info!("一般信息");
log::warn!("警告信息");
log::error!("错误信息");
```

---

*文档版本: 1.0*  
*最后更新: 2026年1月*
