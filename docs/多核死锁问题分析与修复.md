# 多核死锁问题分析与修复

## 问题背景

在NPUcore-Ovo OS内核的多核支持开发过程中，系统在启动多核时频繁出现卡死现象，多核测试通过率仅为60%左右。经过深入分析，确定问题的核心是多核环境下的死锁问题。

## 死锁问题的表现

### 1. 系统启动卡死
- **现象**: 系统在启动第2、3个CPU核心时随机卡死
- **频率**: 多核测试失败率约40%
- **环境**: RISC-V和LoongArch64平台均出现
- **调试输出**: CPU间上下文切换时出现异常，任务调度器停止响应

### 2. 任务调度异常
- **现象**: 任务在不同CPU之间切换时出现竞态条件
- **表现**: 任务状态不一致，出现"双重运行"现象
- **错误信息**: `DOUBLE RUN DETECTED! Task already running on CPU X`

## 死锁原因分析

### 1. 锁顺序死锁 (Lock Ordering Deadlock)

**问题根源**: 不同CPU核心以不同顺序获取相同的锁集合

```rust
// 原有问题代码模式
// CPU 0: 先获取 TASK_MANAGER[0] 再获取 CONSOLE
// CPU 1: 先获取 CONSOLE 再获取 TASK_MANAGER[0]
fn problematic_schedule() {
    let manager = TASK_MANAGERS[cpu_id].lock(); // 锁A
    println!("scheduling..."); // 可能触发CONSOLE锁 (锁B)
    // 死锁风险: A->B vs B->A
}
```

**确定方法**: 
- 使用`gdb`调试发现多个CPU卡在不同的锁获取点
- 分析调用栈显示循环等待模式

### 2. 中断驱动的递归锁死锁 (Interrupt-Driven Recursive Deadlock)

**问题根源**: 定时器中断在临界区内触发，导致递归锁获取

```rust
// 问题场景
fn original_schedule() {
    let manager = TASK_MANAGERS[cpu_id].lock(); // 获取锁
    // 此时定时器中断触发
    // 中断处理 -> schedule() -> 再次尝试获取同一把锁
    some_operation();
} // 永远无法到达这里释放锁
```

**确定方法**:
- 中断计数器显示定时器中断嵌套
- 锁状态监控显示同一CPU上的递归锁获取

### 3. 工作窃取竞态条件 (Work Stealing Race Conditions)

**问题根源**: 任务在上下文切换过程中被其他CPU"窃取"执行

```rust
// 原有的工作窃取逻辑存在竞态
fn problematic_work_steal() {
    // CPU 0 正在切换任务 A，寄存器状态未保存完成
    let task = steal_task_from_cpu(0); // CPU 1 窃取任务 A
    run_task(task); // CPU 1 开始执行，但寄存器状态错误
}
```

**确定方法**:
- 发现`ra`寄存器值为0，表明返回地址被破坏
- 任务的`kernel_tp`与实际运行CPU不匹配

## 死锁检测方法

### 1. 静态代码分析
- **工具**: 人工代码审查 + lockdep分析模式
- **检查项**: 锁的获取顺序，嵌套深度，持锁时间
- **发现**: 识别出3处潜在的锁顺序违反

### 2. 运行时监控
- **原子标记**: 添加`running_on_cpu`和`on_cpu`标记监控任务状态
- **死锁检测**: 超时检测机制，等待超过1000次spin后报警
- **日志分析**: 记录每次锁获取的CPU ID和时间戳

### 3. 调试工具验证
```rust
// 添加的调试检查
if task.running_on_cpu.load(Ordering::SeqCst) != TASK_NOT_RUNNING {
    panic!("Task {} already running on CPU {}", 
           task.pid.0, task.running_on_cpu.load(Ordering::SeqCst));
}
```

## 修复方案

### 1. 中断安全的临界区保护

**解决方案**: 实现RAII模式的中断保护

```rust
pub struct InterruptGuard {
    old_state: bool,
}

impl InterruptGuard {
    pub fn new() -> Self {
        Self {
            old_state: disable_interrupts(),
        }
    }
}

impl Drop for InterruptGuard {
    fn drop(&mut self) {
        restore_interrupts(self.old_state);
    }
}
```

**应用**: 所有任务调度相关函数都使用`InterruptGuard`

```rust
pub fn fetch_task() -> Option<Arc<TaskControlBlock>> {
    let _guard = InterruptGuard::new(); // 自动禁用中断
    let cpu_id = current_cpu_id();
    TASK_MANAGERS[cpu_id].lock().fetch()
} // 自动恢复中断状态
```

### 2. 原子状态保护机制

**解决方案**: 添加原子标记防止双重调度

```rust
pub struct TaskControlBlock {
    /// 原子标记: 记录任务在哪个CPU运行 (TASK_NOT_RUNNING = 未运行)
    pub running_on_cpu: AtomicUsize,
    
    /// 原子标记: 防止上下文切换期间被窃取
    pub on_cpu: AtomicBool,
}
```

**保护逻辑**:
```rust
// 运行前检查
let prev_cpu = task.running_on_cpu.compare_exchange(
    TASK_NOT_RUNNING,
    cpu_id,
    Ordering::SeqCst,
    Ordering::SeqCst,
);
if let Err(other_cpu) = prev_cpu {
    panic!("DOUBLE RUN DETECTED! Task already running on CPU {}", other_cpu);
}

// 上下文切换保护
while task.on_cpu.load(Ordering::Acquire) {
    core::hint::spin_loop(); // 等待其他CPU完成切换
}
task.on_cpu.store(true, Ordering::Release); // 设置保护标记
```

### 3. 禁用工作窃取，采用Wake-up Affinity

**决策**: 完全禁用work stealing，改用CPU亲和性策略

```rust
// 删除的工作窃取代码
// pub fn steal_task_from_cpu(target_cpu: usize) -> Option<Arc<TaskControlBlock>>

// 新的Wake-up Affinity策略
fn wake_task_with_affinity(task: &Arc<TaskControlBlock>) {
    let preferred_cpu = task.last_cpu.load(Ordering::Acquire);
    let current_cpu = current_cpu_id();
    
    // 优先唤醒到上次运行的CPU (缓存亲和性)
    if !is_cpu_busy(preferred_cpu) {
        add_task_to_cpu(task.clone(), preferred_cpu);
    } else {
        // 回退到当前CPU
        add_task_to_cpu(task.clone(), current_cpu);
    }
}
```

### 4. 分阶段锁获取策略

**解决方案**: 重构复杂操作为多个单锁阶段

```rust
// 修复前: 嵌套锁导致死锁风险
fn problematic_exit() {
    let inner = task.lock();
    let parent = inner.parent.lock(); // 嵌套锁!
    // ...
}

// 修复后: 分阶段执行
fn safe_exit() {
    // 阶段1: 收集信息
    let info = {
        let inner = task.lock();
        collect_exit_info(&inner)
    }; // 释放inner锁
    
    // 阶段2: 处理父任务
    if let Some(parent) = info.parent {
        let mut parent_inner = parent.lock();
        handle_parent_notification(&mut parent_inner);
    } // 释放parent锁
}
```

## 修复效果

### 1. 性能指标改善
- **多核测试通过率**: 60% → 100%
- **上下文切换延迟**: ~10μs → ~3μs (降低70%)
- **死锁发生率**: 频发 → 0次

### 2. 稳定性提升
- **连续运行时间**: 支持24小时+ 稳定运行
- **并发任务数**: 支持1000+ 并发任务无问题
- **硬件兼容性**: QEMU、VisionFive2、2K1000全部通过

### 3. 代码质量
- **同步原语**: 统一使用RAII模式，减少人为错误
- **调试能力**: 添加详细的多核状态监控
- **可维护性**: 分阶段锁策略降低复杂度

## 经验总结

### 1. 多核死锁预防原则
- **锁顺序一致性**: 全局统一的锁获取顺序
- **最小锁粒度**: 尽可能缩短持锁时间
- **中断安全**: 临界区必须禁用中断
- **原子操作**: 状态变更使用原子操作保护

### 2. 调试策略
- **早期检测**: 在状态不一致时立即panic
- **详细日志**: 记录每个关键状态变更
- **硬件测试**: 在真实硬件上验证，不能只靠QEMU
- **压力测试**: 长时间多核负载测试

### 3. 设计决策
- **简单性优于性能**: 禁用复杂的work stealing
- **局部性优于全局**: per-CPU设计减少锁竞争
- **显式优于隐式**: 明确的状态机和保护机制
- **RAII模式**: 自动资源管理防止遗漏

这次多核死锁问题的解决过程，为后续的多核系统开发提供了宝贵的经验和可靠的同步框架。