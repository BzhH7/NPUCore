# NPUcore-Ovo 系统架构设计文档

## 1. 架构概述

### 1.1 整体架构

NPUcore-Ovo 采用分层架构设计，从底层硬件到用户应用程序分为以下层次：

```
┌─────────────────────────────────────────────────────────────┐
│                     用户应用程序层                            │
│              (User Applications / Shell)                    │
├─────────────────────────────────────────────────────────────┤
│                     系统调用接口层                            │
│                  (System Call Interface)                    │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐  │
│  │   进程管理   │   内存管理   │   文件系统   │   网络协议栈  │  │
│  │   (Task)    │    (MM)     │    (FS)     │    (Net)    │  │
│  └─────────────┴─────────────┴─────────────┴─────────────┘  │
├─────────────────────────────────────────────────────────────┤
│                     设备驱动层                               │
│                    (Drivers)                                │
├─────────────────────────────────────────────────────────────┤
│                   硬件抽象层 (HAL)                            │
│     ┌──────────────────┬──────────────────┐                 │
│     │     RISC-V       │    LoongArch     │                 │
│     │   (rv64/sv39)    │    (la64/flex)   │                 │
│     └──────────────────┴──────────────────┘                 │
├─────────────────────────────────────────────────────────────┤
│                     硬件层                                   │
│            (QEMU / VisionFive2 / 2K1000)                    │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 设计原则

1. **模块化设计**: 各功能模块相互独立，通过定义良好的接口交互
2. **硬件抽象**: 通过 HAL 层隔离硬件差异，实现跨架构支持
3. **安全隔离**: 内核态与用户态严格分离，使用虚拟内存保护
4. **可扩展性**: 支持通过 Feature Flag 启用/禁用功能模块

## 2. 硬件抽象层 (HAL)

### 2.1 HAL 架构

```
hal/
├── mod.rs              # HAL 公共接口定义
├── arch/
│   ├── riscv/          # RISC-V 架构实现
│   │   ├── config.rs   # 平台配置
│   │   ├── entry.asm   # 启动入口
│   │   ├── sv39.rs     # Sv39 页表实现
│   │   ├── trap/       # 中断/异常处理
│   │   ├── switch.S    # 上下文切换
│   │   └── sbi.rs      # SBI 接口
│   └── loongarch64/    # LoongArch 架构实现
│       ├── config.rs   # 平台配置
│       ├── entry.asm   # 启动入口
│       ├── laflex.rs   # 页表实现
│       ├── trap/       # 中断/异常处理
│       ├── switch.S    # 上下文切换
│       └── register/   # 寄存器定义
├── configs/            # 通用配置
└── platform/           # 平台特定代码
    ├── riscv/          # RISC-V 平台
    └── loongarch64/    # LoongArch 平台
```

### 2.2 HAL 公共接口

HAL 层向上层提供统一的接口：

```rust
// 导出的公共接口
pub use arch::__switch;           // 上下文切换
pub use arch::config;             // 平台配置
pub use arch::kstack_alloc;       // 内核栈分配
pub use arch::shutdown;           // 系统关机
pub use arch::tlb_invalidate;     // TLB 刷新
pub use arch::{bootstrap_init, machine_init};  // 初始化
pub use arch::{console_putchar, console_getchar}; // 控制台 I/O
pub use arch::{trap_handler, trap_return};     // 陷阱处理
pub use arch::{KernelPageTableImpl, PageTableImpl}; // 页表实现
pub use arch::{TrapContext, MachineContext};   // 上下文结构
```

### 2.3 平台支持

| 架构 | 平台 | Feature Flag | 页表实现 |
|------|------|-------------|---------|
| RISC-V | QEMU virt | `board_rvqemu` | Sv39 |
| RISC-V | VisionFive2 | `board_visionfive2` | Sv39 |
| LoongArch | QEMU | `board_laqemu` | LAFlex |
| LoongArch | 2K1000 | `board_2k1000` | LAFlex |

## 3. 内存管理子系统

### 3.1 内存布局

```
RISC-V (QEMU) 内存布局:
┌────────────────────────────────────────┐ 0xFFFF_FFFF_FFFF_FFFF
│              跳板页 (Trampoline)         │
├────────────────────────────────────────┤
│              用户栈空间                   │
├────────────────────────────────────────┤
│              MMAP 区域                   │ MMAP_BASE
├────────────────────────────────────────┤
│              用户堆空间                   │
├────────────────────────────────────────┤
│              用户代码/数据段              │
├────────────────────────────────────────┤ 0x0000_0000_0000_0000

内核空间 (高地址映射):
┌────────────────────────────────────────┐ MEMORY_END
│              帧分配器管理区域             │
├────────────────────────────────────────┤
│              内核堆                      │
├────────────────────────────────────────┤
│              内核栈                      │
├────────────────────────────────────────┤
│              .bss                       │
├────────────────────────────────────────┤
│              .data                      │
├────────────────────────────────────────┤
│              .rodata                    │
├────────────────────────────────────────┤
│              .text                      │
├────────────────────────────────────────┤ 0x8020_0000 (KERNEL_ENTRY)
```

### 3.2 内存管理组件

```
mm/
├── mod.rs              # 模块入口
├── address.rs          # 地址类型定义
├── page_table.rs       # 页表抽象
├── frame_allocator.rs  # 物理页帧分配器
├── heap_allocator.rs   # 内核堆分配器
├── memory_set.rs       # 地址空间管理
├── map_area.rs         # 内存区域映射
└── zram.rs             # ZRAM 压缩内存
```

### 3.3 关键数据结构

```rust
/// 地址空间
pub struct MemorySet<T: PageTable> {
    page_table: T,           // 页表实现
    areas: Vec<MapArea>,     // 映射区域
}

/// 内存区域
pub struct MapArea {
    vpn_range: VPNRange,     // 虚拟页号范围
    map_type: MapType,       // 映射类型
    permission: MapPermission, // 权限
    frames: Vec<Frame>,      // 物理帧
}

/// 映射类型
pub enum MapType {
    Identical,  // 恒等映射
    Framed,     // 分帧映射
    Linear,     // 线性映射
}
```

### 3.4 内存管理特性

- **写时复制 (CoW)**: 延迟分配，提高 fork 效率
- **按需分页**: 访问时才分配物理页
- **ZRAM 压缩**: 内存紧张时压缩不活跃页面
- **Swap 支持**: 支持将页面交换到磁盘

## 4. 进程管理子系统

### 4.1 任务模型

```
task/
├── mod.rs          # 模块入口
├── task.rs         # 任务控制块
├── manager.rs      # 任务调度器
├── processor.rs    # 处理器抽象
├── context.rs      # 任务上下文
├── pid.rs          # PID 分配
├── signal.rs       # 信号处理
├── threads.rs      # 线程/Futex
└── elf.rs          # ELF 加载器
```

### 4.2 任务控制块 (TCB)

```rust
pub struct TaskControlBlock {
    // 不可变字段
    pub pid: PidHandle,       // 进程 ID
    pub tid: usize,           // 线程 ID
    pub tgid: usize,          // 线程组 ID
    pub kstack: KernelStack,  // 内核栈
    
    // 可变字段 (Mutex 保护)
    inner: Mutex<TaskControlBlockInner>,
    
    // 可共享字段
    pub exe: Arc<Mutex<FileDescriptor>>,   // 可执行文件
    pub files: Arc<Mutex<FdTable>>,        // 文件描述符表
    pub vm: Arc<Mutex<MemorySet>>,         // 地址空间
    pub sighand: Arc<Mutex<Vec<SigAction>>>, // 信号处理
    pub futex: Arc<Mutex<Futex>>,          // Futex 表
}
```

### 4.3 任务状态机

```
                    ┌──────────┐
         创建任务    │  Ready   │ 加入就绪队列
           │        └────┬─────┘
           ▼             │
    ┌──────────┐    调度  │
    │  Ready   │◀────────┘
    └────┬─────┘
         │ 被调度执行
         ▼
    ┌──────────┐
    │ Running  │
    └────┬─────┘
         │
    ┌────┴────┬──────────────┐
    │         │              │
    ▼         ▼              ▼
┌──────┐  ┌────────┐   ┌──────────┐
│Ready │  │Blocked │   │  Zombie  │
└──────┘  └────────┘   └──────────┘
  时间片     等待事件      exit()
  用完
```

### 4.4 调度策略

当前实现采用简单的 **时间片轮转 (Round-Robin)** 调度：
- 每个 CPU 核心维护独立的就绪队列
- 时钟中断触发抢占式调度
- 支持任务主动让出 CPU (yield)

## 5. 文件系统子系统

### 5.1 VFS 架构

```
            用户空间
               │
               │ 系统调用
               ▼
        ┌─────────────┐
        │     VFS     │ 虚拟文件系统
        └──────┬──────┘
               │
    ┌──────────┼──────────┐
    │          │          │
    ▼          ▼          ▼
┌───────┐ ┌───────┐ ┌───────┐
│ FAT32 │ │ EXT4  │ │ DevFS │
└───┬───┘ └───┬───┘ └───┬───┘
    │         │         │
    ▼         ▼         ▼
┌─────────────────────────────┐
│      Page Cache / Buffer    │
└──────────────┬──────────────┘
               │
               ▼
        ┌─────────────┐
        │ Block Device│
        └─────────────┘
```

### 5.2 文件系统组件

```
fs/
├── mod.rs              # 模块入口
├── vfs.rs              # 虚拟文件系统
├── file_trait.rs       # 文件抽象 trait
├── file_descriptor.rs  # 文件描述符
├── directory_tree.rs   # 目录树
├── cache.rs            # 页面缓存
├── fat32/              # FAT32 实现
├── ext4/               # EXT4 实现
├── dev/                # 设备文件
│   ├── pipe.rs         # 管道
│   ├── tty.rs          # 终端
│   └── null.rs         # /dev/null
├── poll.rs             # I/O 多路复用
└── swap.rs             # 交换分区
```

### 5.3 文件抽象

```rust
/// 文件 trait
pub trait File: Send + Sync + Downcast {
    fn readable(&self) -> bool;
    fn writable(&self) -> bool;
    fn read(&self, offset: Option<&mut usize>, buf: &mut [u8]) -> usize;
    fn write(&self, offset: Option<&mut usize>, buf: &[u8]) -> usize;
    fn seek(&self, offset: isize, whence: SeekWhence) -> usize;
    fn stat(&self) -> Stat;
    // ... 更多方法
}
```

## 6. 系统调用接口

### 6.1 系统调用分类

| 类别 | 系统调用示例 |
|------|-------------|
| 进程控制 | fork, execve, exit, wait4, clone |
| 文件操作 | open, read, write, close, lseek |
| 目录操作 | mkdirat, getdents64, chdir |
| 内存管理 | mmap, munmap, brk, mprotect |
| 信号处理 | sigaction, sigprocmask, kill |
| 网络通信 | socket, bind, listen, connect |
| 时间管理 | clock_gettime, nanosleep |

### 6.2 系统调用处理流程

```
用户态                              内核态
  │                                   │
  │  ecall/syscall 指令               │
  │ ─────────────────────────────────▶│
  │                                   │
  │                            ┌──────┴──────┐
  │                            │ trap_handler │
  │                            └──────┬──────┘
  │                                   │
  │                            ┌──────┴──────┐
  │                            │  syscall()  │
  │                            │  分发函数    │
  │                            └──────┬──────┘
  │                                   │
  │                            ┌──────┴──────┐
  │                            │  具体实现    │
  │                            │  sys_xxx()  │
  │                            └──────┬──────┘
  │                                   │
  │  sret/eret 返回                   │
  │ ◀─────────────────────────────────│
  │                                   │
```

## 7. 网络子系统

### 7.1 网络协议栈

基于 **smoltcp** 实现 TCP/IP 协议栈：

```
应用层
  │
  ▼
┌─────────────┐
│   Socket    │
│  TCP / UDP  │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   smoltcp   │
│  协议栈     │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   网卡驱动   │
└─────────────┘
```

### 7.2 支持的协议

- IPv4 / IPv6
- TCP
- UDP
- DHCP 客户端
- IP 分片重组

## 8. 启动流程

### 8.1 RISC-V 启动流程

```
1. OpenSBI 初始化硬件
        │
        ▼
2. 跳转到 _start (entry.asm)
        │
        ▼
3. 设置栈指针, 清零 BSS
        │
        ▼
4. rust_main() 入口
        │
        ├── BSP (主核)
        │   ├── mem_clear()
        │   ├── mm::init()
        │   ├── trap::init()
        │   ├── 初始化块设备
        │   ├── 挂载根文件系统
        │   ├── 加载 initproc
        │   └── run_tasks()
        │
        └── AP (从核)
            ├── machine_init()
            └── 等待任务调度
```

### 8.2 多核启动

```rust
#[no_mangle]
pub fn rust_main(hart_id: usize) -> ! {
    // 每个核都执行
    machine_init();
    
    // 原子操作判断 BSP
    let is_bsp = !BOOT_FLAG.swap(true, Ordering::SeqCst);
    
    if is_bsp {
        // BSP 执行完整初始化
        // ...
        AP_CAN_START.store(true, Ordering::Release);
    } else {
        // AP 等待 BSP 初始化完成
        while !AP_CAN_START.load(Ordering::Acquire) {
            spin_loop();
        }
    }
    
    run_tasks(); // 进入调度循环
}
```

## 9. 中断与异常处理

### 9.1 RISC-V 陷阱处理

| 陷阱类型 | 处理方式 |
|---------|---------|
| 时钟中断 | 任务调度 |
| 外部中断 | 设备 I/O |
| 系统调用 | ecall 指令 |
| 页面错误 | 按需分页/CoW |
| 非法指令 | 发送 SIGILL |

### 9.2 陷阱处理流程

```
      ┌──────────────┐
      │ __alltraps   │ 保存上下文
      └──────┬───────┘
             │
             ▼
      ┌──────────────┐
      │ trap_handler │ 分发处理
      └──────┬───────┘
             │
    ┌────────┼────────┐
    │        │        │
    ▼        ▼        ▼
  中断     异常     系统调用
             │
             ▼
      ┌──────────────┐
      │ trap_return  │ 恢复上下文
      └──────────────┘
```

## 10. 安全设计

### 10.1 特权级隔离

- 内核运行在 S-Mode (RISC-V) / Ring 0 (LoongArch)
- 用户程序运行在 U-Mode / Ring 3
- 通过 CSR/系统寄存器控制权限

### 10.2 地址空间隔离

- 每个进程拥有独立的页表
- 内核空间映射到所有进程的高地址
- 跳板页实现安全的上下文切换

### 10.3 访问控制

- 页表权限位控制读/写/执行
- 文件权限检查 (umask)
- 信号权限验证

---

*文档版本: 1.0*  
*最后更新: 2026年1月*
