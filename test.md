# 2025中西部区域赛内核赛道决赛赛题

本次决赛线上现场赛包含三个题目，各50分，总分150分。

### 题目1（50分）：系统调用 close_range

`close_range` 是一个Linux系统调用，用于高效地关闭指定范围内的所有文件描述符。相比于在循环中多次调用 `close`，`close_range` 能够原子性地或更高效地批量处理文件描述符，常用于进程启动前清理文件描述符的场景（如 `fork` 后 `exec` 前）。

#### 函数原型

```c
#include <unistd.h>

int close_range(unsigned int first, unsigned int last, unsigned int flags);
```

#### 参数

- **first**: 指定要关闭的文件描述符范围的起始值（包含）。
- **last**: 指定要关闭的文件描述符范围的结束值（包含）。如果该值为 `~0U` (即 `UINT_MAX`)，则表示关闭从 `first` 开始直到最大可能文件描述符的所有描述符。
- **flags**: 控制行为的标志位。
  - `CLOSE_RANGE_CLOEXEC` (bit 2): 如果设置了此标志，则不关闭指定范围内的文件描述符，而是将它们的 `FD_CLOEXEC` 标志置位（即设置 Close-on-Exec 属性）。

#### 返回值

- 成功时返回 0。
- 出错时返回 -1 并设置 errno（例如：如果 `flags` 包含无效位，返回 `EINVAL`）。

#### 特殊说明

1. **边界处理**：如果 `first` 大于 `last`，调用应直接返回 0（成功），不执行任何操作。
2. **空洞处理**：文件描述符表通常是稀疏的。对于指定范围内未打开（已关闭）的文件描述符，系统调用应静默忽略，不应返回错误。
3. **原子性与效率**：虽然实现上可能需要遍历，但从用户态看应表现为批量操作。

#### 测试点说明

本题目的评测包含 5 个测试点，每个测试点10分：

1. **基本功能**：创建一个连续的文件描述符区间，调用 `close_range` 关闭中间一段，验证范围内已关闭，范围外仍可用。
2. **最大范围关闭**：传入 `last = ~0U`，验证是否能正确关闭从起始点到上限的所有文件描述符。
3. **错误处理**：验证 `first > last` 时的行为以及无效 `flags` 的检查。
4. **CLOEXEC 标志**：使用 `CLOSE_RANGE_CLOEXEC` 标志，验证文件描述符是否**未被关闭**，但其属性中包含了 `FD_CLOEXEC`。
5. **稀疏表容错**：构造一个包含已关闭文件描述符（空洞）的范围进行操作，验证系统是否能正确跳过空洞而不报错。

------

### 题目2（50分）：系统调用 eventfd2

`eventfd` 是一种极其轻量级的进程/线程间通信机制，本质上是内核维护的一个 64 位无符号整数计数器。它支持类似于文件的 `read`/`write` 操作，常用于事件通知、信号量模拟等场景。

#### 函数原型

```c
#include <sys/eventfd.h>

int eventfd2(unsigned int initval, int flags);
```

#### 参数

- **initval**: 计数器的初始值。
- **flags**: 创建标志位。
  - `EFD_CLOEXEC`: 设置文件描述符的 Close-on-Exec 属性。
  - `EFD_NONBLOCK`: 设置非阻塞 I/O 属性。
  - `EFD_SEMAPHORE`: 提供类似信号量的读取语义。

#### 返回值

- 成功时返回一个新的文件描述符。
- 出错时返回 -1 并设置 errno。

#### 特殊说明

1. **Write 操作**：向计数器累加一个 64 位整数。如果相加结果会导致计数器溢出（超过 `UINT64_MAX-1`），则阻塞写入（或在非阻塞模式下返回 `EAGAIN`）。
2. **Read 操作**：
   - **默认模式**：如果计数器大于 0，读取返回当前值，并将计数器重置为 0。
   - **信号量模式 (`EFD_SEMAPHORE`)**：如果计数器大于 0，读取返回 1，并将计数器减 1。
   - 如果计数器为 0，则阻塞读取（或在非阻塞模式下返回 `EAGAIN`）。
3. **对象共享**：`eventfd` 返回的是一个文件描述符。如果使用 `dup` 复制该描述符，或者 `fork` 子进程，所有描述符应指向**同一个**内核计数器对象（即在一个描述符上写入，在另一个上能读到）。

#### 测试点说明

本题目的评测包含 5 个测试点，每个测试点10分：

1. **基本读写**：写入值 X，读取得到 X，再次读取应阻塞或返回 0（取决于实现，通常阻塞）。
2. **信号量模式**：设置 `EFD_SEMAPHORE`。写入 3，需连续 3 次 `read` 均返回 1，第 4 次阻塞。
3. **非阻塞与边界**：设置 `EFD_NONBLOCK`。验证空读返回 `EAGAIN`，以及最大值溢出写保护。
4. **累积读写**：多次小额 `write`，一次 `read` 应读出累加的总和。
5. **句柄共享与标志位**：
   - 验证 `EFD_CLOEXEC` 是否正确设置了 FD 属性。
   - 使用 `dup` 复制句柄，验证 `fd1` 写入的数据能否被 `fd2` 读取，考察内核文件对象的引用计数与共享机制。

------

### 题目3（50分）：系统调用 waitid

`waitid` 系统调用提供了比传统的 `wait` 和 `waitpid` 更精细的子进程状态控制接口。它允许父进程等待子进程的特定状态改变（如退出、停止、继续），并通过 `siginfo_t` 结构体返回非常详细的事件信息。

#### 函数原型

```c
#include <sys/wait.h>

int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
```

#### 参数

- **idtype**: 指定 `id` 参数的解释方式。
  - `P_PID`: 等待 PID 等于 `id` 的子进程。
  - `P_PGID`: 等待进程组 ID 等于 `id` 的任意子进程。
  - `P_ALL`: 等待任意子进程，忽略 `id`。
- **id**: 根据 `idtype` 指定的 PID 或 PGID。
- **infop**: 指向 `siginfo_t` 结构体的指针，用于内核填充子进程的状态信息（如 `si_pid`, `si_status`, `si_code`）。
- **options**: 行为控制掩码。
  - `WEXITED`: 等待已结束的子进程。
  - `WSTOPPED`: 等待被信号暂停的子进程。
  - `WCONTINUED`: 等待被信号恢复的子进程。
  - `WNOHANG`: 非阻塞模式，如果无子进程状态改变则立即返回。
  - `WNOWAIT`: 状态改变后不消耗该状态（保持僵尸状态），可供后续等待。

#### 返回值

- 成功时返回 0。如果设置了 `WNOHANG` 且没有状态改变，也返回 0，此时 `infop->si_pid` 应为 0。
- 出错时返回 -1 并设置 errno。

#### 特殊说明

1. **状态反馈**：内核必须正确填充 `siginfo_t` 中的关键字段：
   - `si_pid`: 发生事件的子进程 ID。
   - `si_uid`: 子进程的用户 ID。
   - `si_code`: 事件类型（`CLD_EXITED` 正常退出, `CLD_KILLED` 被杀, `CLD_STOPPED` 暂停, `CLD_CONTINUED` 继续）。
   - `si_status`: 退出码或导致状态改变的信号值。
2. **进程状态机**：内核需维护进程的 `Stopped` 和 `Continued` 状态，并在状态切换时唤醒等待的父进程。

#### 测试点说明

本题目的评测包含 4 个测试点，每个测试点12.5分：

1. **基本退出等待**：等待子进程正常退出，验证 `si_code` 为 `CLD_EXITED` 及退出码正确。
2. **非阻塞等待**：使用 `WNOHANG`，验证子进程运行时返回 0，退出后成功捕获状态。
3. **被信号杀死**：子进程被 `SIGKILL` 杀死，验证 `si_code` 为 `CLD_KILLED` 及信号值。
4. **进程组等待**：创建属于同一进程组的多个子进程，验证使用 `P_PGID` 能正确回收组内任意进程。
